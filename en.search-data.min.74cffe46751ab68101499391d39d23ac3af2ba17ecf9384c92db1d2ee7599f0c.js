'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/COMP4901O/','title':"COMP4901O - Competitive Programming in Cybersecurity II",'section':"Home",'content':"COMP4901O - Competitive Programming in Cybersecurity II The course will be offered as an 1-credit course in the Spring semester. Students who have passed COMP4901N and have gotten the instructor consent can join COMP4901O in a subsequent Spring semester, they will be working together based on the knowledge they have learned from COMP4901O, forming teams to further investigate various advanced topics related to the more practical side of cybersecurity. They will then join the various cybersecurity contests. The students will get 1 credit for successfully completing COMP4901O. Contest-type “attack and defend” programming problems (also known as Capture-The-Flag, CTF, problems) will be employed throughout this course to practically train the students for the cybersecurity contests. The topics covered will include but not limited to binary analysis, cryptography, web exploitations, and packet capture analysis. These topics will be covered in the practical attack-and-defend context. Recent developments in the topics will also be investigated by students via CTF problem solving. Instructor\u0026rsquo;s approval is required.\n  Zer0pts CTF 2021: 3-AES   Writeup for 3-AES from Zer0pts CTF 2021   "});index.add({'id':1,'href':'/COMP4901O/zer0pts-CTF-2021-3-AES/','title':"Zer0pts CTF 2021: 3-AES",'section':"COMP4901O - Competitive Programming in Cybersecurity II",'content':"3-AES Problem Description  3-DES is more secure than DES. Then, 3-AES is more secure than AES of course! nc crypto.ctf.zer0pts.com 10929\nAttachment server.py\nfrom Crypto.Cipher import AES from Crypto.Random import get_random_bytes from binascii import hexlify, unhexlify from hashlib import md5 import os import signal from flag import flag keys = [md5(os.urandom(3)).digest() for _ in range(3)] def get_ciphers(iv1, iv2): return [ AES.new(keys[0], mode=AES.MODE_ECB), AES.new(keys[1], mode=AES.MODE_CBC, iv=iv1), AES.new(keys[2], mode=AES.MODE_CFB, iv=iv2, segment_size=8*16), ] def encrypt(m: bytes, iv1: bytes, iv2: bytes) -\u0026gt; bytes: assert len(m) % 16 == 0 ciphers = get_ciphers(iv1, iv2) c = m for cipher in ciphers: c = cipher.encrypt(c) return c def decrypt(c: bytes, iv1: bytes, iv2: bytes) -\u0026gt; bytes: assert len(c) % 16 == 0 ciphers = get_ciphers(iv1, iv2) m = c for cipher in ciphers[::-1]: m = cipher.decrypt(m) return m signal.alarm(3600) while True: print(\u0026#34;==== MENU ====\u0026#34;) print(\u0026#34;1. Encrypt your plaintext\u0026#34;) print(\u0026#34;2. Decrypt your ciphertext\u0026#34;) print(\u0026#34;3. Get encrypted flag\u0026#34;) choice = int(input(\u0026#34;\u0026gt; \u0026#34;)) if choice == 1: plaintext = unhexlify(input(\u0026#34;your plaintext(hex): \u0026#34;)) iv1, iv2 = get_random_bytes(16), get_random_bytes(16) ciphertext = encrypt(plaintext, iv1, iv2) ciphertext = b\u0026#34;:\u0026#34;.join([hexlify(x) for x in [iv1, iv2, ciphertext]]).decode() print(\u0026#34;here\u0026#39;s the ciphertext: {}\u0026#34;.format(ciphertext)) elif choice == 2: ciphertext = input(\u0026#34;your ciphertext: \u0026#34;) iv1, iv2, ciphertext = [unhexlify(x) for x in ciphertext.strip().split(\u0026#34;:\u0026#34;)] plaintext = decrypt(ciphertext, iv1, iv2) print(\u0026#34;here\u0026#39;s the plaintext(hex): {}\u0026#34;.format(hexlify(plaintext).decode())) elif choice == 3: plaintext = flag iv1, iv2 = get_random_bytes(16), get_random_bytes(16) ciphertext = encrypt(plaintext, iv1, iv2) ciphertext = b\u0026#34;:\u0026#34;.join([hexlify(x) for x in [iv1, iv2, ciphertext]]).decode() print(\u0026#34;here\u0026#39;s the encrypted flag: {}\u0026#34;.format(ciphertext)) exit() else: exit()     Reading the Source Code After taking a look at the source code, here are some noteworthy observations we can see:\n We have the ability to encrypt plaintext, decrypt ciphertext, and see the encrypted flag. The keys used for encrpytion and decryption are persistent within the session. The keyspace $\\mathcal K$ is the md5 hash of every possible combination of three bytes. That is\n$\\mathcal K = \\{\\text{md5}(b_1b_2b_3)\\ |\\ 0 \\leq b_1,b_2,b_3 \\leq 256\\}$ $|\\mathcal K| = 256^3 = 16,777,216$. Encryption Service  The length of the plaintext has to be a multiple of 16. Our input is unhexlified by the system. Encryption is done in three phases. First encryption in ECB mode with key $k_1$ then encryption in CBC mode with key $k_2$ and iv $IV_1$, and finally encryption in CFB mode with key $k_3$ and iv $IV_2$ where the segment size is $16\\times8$ bits (16 bytes). We control the plaintext. $IV_1$ and $IV_2$ are both a random sequence of 16 bytes. The output is in the form of hexlify(iv1):hexlify(iv2):hexlify(ciphertext).   Decryption Service  The length of the ciphertext has to be a multiple of 16. Our input is unhexlified, and is in the form of hexlify(iv1):hexlify(iv2):hexlify(ciphertext). Decryption is done in three phases. First the ciphertext is decrypted in CFB mode with key $k_3$ and iv $IV_2$, then decrypted again in CBC mode with key $k_2$ and iv $IV_1$, and finally decrypted one last time in ECB mode with key $k_1$. We control the ciphertext, $IV_1$, and $IV_2$ which are supplied. The output is in the form hexlify(plaintext).   Seeing the Encrypted Flag Service  The flag is encrypted the same way a message is encrypted in the encryption service. The plaintext used is the flag $IV_1$ and $IV_2$ are both a random sequence of 16 bytes. The output is in the form of hexlify(iv1):hexlify(iv2):hexlify(flag_ciphertext)     What is the Problem? Obviously we want to get the flag which is encrypted with $k_1,k_2$, and $k_3$. So, the goal is to obtain $k_1,k_2$, and $k_3$ it seems. The naive approach to brute force all the keys would take $256^9$ attempts at most; even trying a portion of those keys would take ages. Thus we have to look at how the messages are encrypted and spot any flaws.\nHow Messages Are Encrypted and Decrypted Using Wikipedia as a guide, we can draw the encryption process as a graph. For simplicity, let us make the message blocks just 16 bytes long. This way there is no padding (which wouldnt\u0026rsquo;ve happened anyways) and there is no splitting of blocks.\n In this diagram, the blocks are AES cipher blocks which take an input of 16 bytes, keys of 16 bytes, and outputs 16 bytes.\n Approach Prerequisites Meet in the Middle Meet in the middle is a known plaintext attack used when there are multiple encryption operations in sequence. Take a look at this scenario for example:\n One could crack both keys in at most $|\\mathcal K_1|\\times |\\mathcal K_2|$ operations with a meet in the middle attack where $\\mathcal K_1$ and $\\mathcal K_2$ are the keyspaces of $k_1$ and $k_2$ respectively. This would be done by creating a set $X^\\prime$ such that $X^\\prime$ contains all the possible outputs of the encryption block with a constant plaintext $p$, for all $k \\in \\mathcal K_1$, and another set $X^{\\prime \\prime}$ which contains all the possiblle outputs from decrypting the known $c$ with all keys $k \\in K_2$. Once you find an intersection between $X^\\prime$ and $X^{\\prime \\prime}$, then you would have found a potential $k_1$ and $k_2$. To verify, simply try encrypting a different plaintext and see if the output matches your self encrypted value.\nNotation Lets denote an AES block encryption as $E(k,p)$ where $k$ is the key, and $p$ is the plaintext. And AES block decryption as $D(k,c)$ where $c$ is the ciphertext.\n Step 1: Cracking $k_1$ In order to crack $k_1$ we can first encrypt $p_1$ using the service. From this we can obtain $c_1, IV_1$, and $IV_2$.\nIf we then decrypt $c_1$ using the service supplying 16 null bytes as $IV_1$ and use the same $IV_2$ we obtained from our first encryption we can obtain $p_2$.\nWe can see that\n $D(k_2,z) = y,\\ z = c_1 \\oplus E(k_3, IV_2)$ $E(k_1, p_1) = x$ $p_2 = D(k_1, y) \\implies E(k_1, p_2) = y$ $y \\oplus IV_1 = x$     We now have a relation between $p_1$ and $p_2$. By searching through the entire keyspace for a key $k$ such that $E(k,p_2) \\oplus IV_1 = E(k, p_1)$ then we have found $k_1$.\nStep 2: Gather More Information In this step, we want to gather more information about $k_2$ and $k_3$. With knowledge of $k_1$ we can essentially nullify the effect of the first encryption block.\nSo prepare a plaintext $p_{\\text{empty}} = D(k_1, \\text{null})$, and send $p_{\\text{empty}}$ to the encryption service to obtain $IV_{12}, IV_{22}$ and $c_{12}$.\nNext we want to recieve the encrypted flag because we have enough information at this point to crack the remaining keys.\nLets save the encrypted flag as $IV_{1 \\text{ flag}}, IV_{2 \\text{ flag}}$ and $c_{\\text{flag}}$.\nStep 3: Crack the Keys When we decrypted the null bytes using $k_1$ in the previous step, then encrpyted it as a message, the ciphertext $c_{12} = E(k_2, IV_{12}) \\oplus E(k_3, IV_{22})$. As a diagram:\n With this, we can see that we can crack the keys using meet in the middle.\nLet $X^\\prime = \\{E(k,IV_{12}),\\ \\forall k \\in \\mathcal K\\}$ and $X^{\\prime \\prime} = \\{E(k, IV_{22}) \\oplus c_{12}, \\ \\forall k \\in \\mathcal K)\\}$\nLet $K_2, K_3$ be the potential values of $k_2$ and $k_3$ respectively.\n$K_2 = \\{k \\ | \\ E(k, IV_{12}) \\in X^\\prime \\cap X^{\\prime \\prime}\\}$\n$K_3 = \\{k \\ | \\ E(k, IV_{22}) \\oplus c_{12} \\in X^\\prime \\cap X^{\\prime \\prime}\\}$\nThen every combination of keys $k_2$ and $k_3$ are in $K_2 \\times K_3$.\nStep 4: Decrypt the Flag With all of our potential sets of keys $k_1, k_2, k_3$, we can now try to decrypt the flag. I have found that returning after the first collision between $X^\\prime$ and $X^{\\prime \\prime}$ is fine as the chance of more collisions is extremely low. So, finally decrypting the flag with our keys yields:\nzer0pts{5kip_7h3_midd13_4nd_m337_in_7h3_midd13!}\n Solve Script 3aes_solution.py\nfrom pwn import * from Crypto.Cipher import AES from Crypto.Random import get_random_bytes from binascii import hexlify, unhexlify from hashlib import md5 import os from tqdm import tqdm from time import time keyspace = [] for b1 in tqdm(range(256)): for b2 in range(256): for b3 in range(256): key = b\u0026#39;\u0026#39; + b1.to_bytes(1,\u0026#39;big\u0026#39;) + b2.to_bytes(1,\u0026#39;big\u0026#39;) + b3.to_bytes(1,\u0026#39;big\u0026#39;) keyspace.append(md5(key).digest()) def prep(iv1, iv2, load): return b\u0026#34;:\u0026#34;.join([hexlify(x) for x in [iv1, iv2, load]]).decode() def clean(inp): return [unhexlify(x) for x in inp.strip().split(b\u0026#39;:\u0026#39;)] def byte_xor(ba1, ba2): return bytes([_a ^ _b for _a, _b in zip(ba1, ba2)]) def encrypt_ecb(key,text): cipher = AES.new(key,AES.MODE_ECB) return cipher.encrypt(text) def decrypt_ecb(key, text): cipher = AES.new(key, AES.MODE_ECB) return cipher.decrypt(text) # IDEA: # Phase 1 # - Encrypt p_1 # - Obtain IV1 # - Obtain IV2 # - Obtain c_1 # - Decrypt c_1 with IV1 = 0 and IV2 same as what was obtained in previous step # - Obtain p_2 # Phase 2 # - For each key in the key space, encrypt p_1 and p_2 and save it in sets A and B # - xor every element in A with IV1 and if it is equal to some element in B, then we now have k1 # Phase 3 # - With k1, encrypt empty bytes, and pass that to the encrypt function as plaintext. # - Obtain IV1_2 which is the input for the CBC block. # - Obtain IV2_2 # - Obtain c_1_2 # Phase 4 # - Get encrypted flag and drop connection # - Meet in the middle. first by trying to encrypt IV1_2 with all possible k2 and put into set C. # Then encrypt IV2_2 and xor with c_1_2. If the result of the xor shows up in C, then all three keys # Are found. # - Decrypt the flag # Phase 5 # - Profit r = remote(\u0026#34;crypto.ctf.zer0pts.com\u0026#34;, 10929) p_1 = b\u0026#39;\\x00\u0026#39;*16 print(\u0026#34;PHASE 1\u0026#34;) r.recvuntil(\u0026#39;\u0026gt; \u0026#39;) r.sendline(b\u0026#39;1\u0026#39;) r.recvuntil(\u0026#39;: \u0026#39;) r.sendline(hexlify(p_1)) r.recvuntil(\u0026#39;: \u0026#39;) iv1, iv2, c_1 = clean(r.recvline()) r.recvuntil(\u0026#39;\u0026gt; \u0026#39;) r.sendline(\u0026#39;2\u0026#39;) r.recvuntil(\u0026#39;: \u0026#39;) package = prep(p_1, iv2, c_1) print(package) r.sendline(package) r.recvuntil(\u0026#39;: \u0026#39;) p_2 = unhexlify(r.recvline().strip()) print(\u0026#34;p_1\u0026#34;, p_1) print(\u0026#34;p_2\u0026#34;,p_2) print(\u0026#34;iv1\u0026#34;, iv1) print(\u0026#34;iv2\u0026#34;, iv2) print(\u0026#34;c_1\u0026#34;, c_1) print(\u0026#34;\\nPHASE 2\u0026#34;) k_1 = None t1 = time() print(\u0026#34;Creating Table...\u0026#34;) for key in keyspace: a = byte_xor(encrypt_ecb(key, p_2),iv1) b = encrypt_ecb(key, p_1) if a == b: print(\u0026#34;KEY 1 FOUND!!!\u0026#34;) k_1 = key break print(\u0026#34;Time taken (seconds):\u0026#34;, time()-t1) print(\u0026#34;k_1\u0026#34;, k_1) print(\u0026#34;\\nPHASE 3\u0026#34;) empty = decrypt_ecb(k_1, p_1) r.recvuntil(\u0026#39;\u0026gt; \u0026#39;) r.sendline(\u0026#39;1\u0026#39;) r.recvuntil(\u0026#39;: \u0026#39;) r.sendline(hexlify(empty)) r.recvuntil(\u0026#39;: \u0026#39;) iv1_2, iv2_2, c_1_2 = clean(r.recvline()) print(\u0026#34;iv1_2\u0026#34;, iv1_2) print(\u0026#34;iv2_2\u0026#34;, iv2_2) print(\u0026#34;c_1_2\u0026#34;, c_1_2) print(\u0026#34;\\nPHASE 4\u0026#34;) r.recvuntil(\u0026#39;\u0026gt; \u0026#39;) r.sendline(\u0026#39;3\u0026#39;) r.recvuntil(\u0026#39;: \u0026#39;) iv1_flag, iv2_flag, c_flag = clean(r.recvline()) r.close() k_2 = None k_3 = None keymap = dict() print(\u0026#34;Searching for keys...\u0026#34;) for i in tqdm(range(len(keyspace))): key = keyspace[i] a = encrypt_ecb(key,iv1_2) b = byte_xor(encrypt_ecb(key,iv2_2), c_1_2) if a in keymap: print(\u0026#34;KEYS FOUND!!\u0026#34;) k_3 = keymap[a] k_2 = key break if b in keymap: print(\u0026#34;KEYS FOUND!!\u0026#34;) k_3 = key k_2 = keymap[b] break keymap[a] = key keymap[b] = key print(\u0026#34;k_1\u0026#34;, k_1) print(\u0026#34;k_2\u0026#34;, k_2) print(\u0026#34;k_3\u0026#34;, k_3) print(\u0026#34;\\nPHASE 5\u0026#34;) def get_ciphers(iv1, iv2, k1,k2,k3): return [ AES.new(k1, mode=AES.MODE_ECB), AES.new(k2, mode=AES.MODE_CBC, iv=iv1), AES.new(k3, mode=AES.MODE_CFB, iv=iv2, segment_size=8*16), ] def decrypt(c: bytes, iv1: bytes, iv2: bytes,keys) -\u0026gt; bytes: assert len(c) % 16 == 0 ciphers = get_ciphers(iv1, iv2,keys[0],keys[1],keys[2]) m = c for cipher in ciphers[::-1]: m = cipher.decrypt(m) return m print(decrypt(c_flag, iv1_flag,iv2_flag,[k_1,k_2,k_3]))    "});index.add({'id':2,'href':'/ELEC1200/','title':"ELEC1200 - A System View of Communications: from Signals to Packets",'section':"Home",'content':"ELEC1200 - A System View of Communications: from Signals to Packets Have you ever wondered what technologies go into your mobile phone or a WiFi hotspot? Through hands on work with a simple but fully functional wireless communication system, you will understand the basic engineering tools used and tradeoffs encountered in the design of these systems. This course is centered on weekly laboratories, each designed to introduce an important concept in the design of these systems. The lab sessions are supported by two one-hour lectures and a tutorial that introduce the concepts for the next laboratory, as well as reviewing and expanding the concepts learned in the previous laboratory.\n  Lecture 6   Bit rate vs Bit error rate, LTI Channel, LTI channel response to bit sequences, Intersybol interference, Eye Diagrams   Lecture 5   Protocols in data communication systems, decoding bits, asynchronous serial communication   Lecture4   Linear Time Invariant Systems, Modelling the Channel, Preview of Protocols   Lecture3   Representing Bit Waveforms, Discrete Time Channel, Effects of the Channel   Lecture2   Recap of lecture 1, Encoding information with bits, Continuous vs Discrete waveforms, Discrete time bit waveforms   "});index.add({'id':3,'href':'/ELEC1200/Lecture6/','title':"Lecture 6",'section':"ELEC1200 - A System View of Communications: from Signals to Packets",'content':"Trade-Off Between bit-rate and BER  Bit rate - the number of bits that can be transmitter per second (we want this to be as high as possible) Bit Error Rate (BER) - Fraction of bits that are wrongly decoded by the reciever.  We want this to be low BER rate decreases as bit time increases BER increases with smaller bit time (SPB) BER increases if the channel is noisier or if we use less power to transmit a signal.    LTI Channel Response to Bit Sequences Effect of Bit Time  For a single isolated bit pulse of width SPB, as SPB decreases:  The time the response has to rise up to its maximum value decreases. The max amplitude decreases   Intuitively if we keep the threshold the same (halfway between the min and max value), what should be detected as a \u0026ldquo;1\u0026rdquo; gets detected as a \u0026ldquo;0\u0026rdquo; (an error has occured) Reason for BER increase with smaller bit time. (bit errors due to not crossing the threshold)  Intersymbol Interference (ISI)  The response to a \u0026ldquo;0\u0026rdquo; or \u0026ldquo;1\u0026rdquo; depends on the bits that were transmitted before it due to the time it takes for the channel to respond to a transition. We refer to this as intersymbol interference. The smaller the bit time, in comparison with the time it takes for the channel to respond to a transition, the greater the ISI  More past symbols interfere with the current symbol This leads to a greater variety of responses we can observe when a zero or one bit is transmitted    Settling Time  The settling time tells us how long it takes for the response to get within 90% of k To find the settling time, find $n$ such that $s(n)= 0.9k$, where $s(n)=k(1-a^{n+1})u(n)$ is the exponential step response.\n$$n_s = \\frac{\\ln 0.1}{\\ln a}-1$$ Larger a $\\implies$ Larger settling time.  "});index.add({'id':4,'href':'/ELEC1200/Lecture5/','title':"Lecture 5",'section':"ELEC1200 - A System View of Communications: from Signals to Packets",'content':"Protocols Agreement on a set of rules or procedures to follow during communication.   Protocols are necessary for any communication system  Without them, one can hear but not understand    Protocols in Data Communication Systems  In data communication, protocols cover all aspects of data representation and signalling including:  The representation of text characters The order in which bit sequences are sent    Decoding Bits Thresholding  In our system, for long SPBs at the reciever:  \u0026ldquo;1\u0026rdquo; bits correspond to a number of samples with value c + k \u0026ldquo;0\u0026rdquo; bits correspond to a number of samples with value c Thus we can decide whether a bit is 0 or 1 by comparing to a threshold of c + k/2 Let $r(n)$ be the recieved signal at time $n$, and $b(n)$ the result of thresholding:\n$$b(n) = \\begin{cases} 1 \u0026amp; r(n) \\geq c + k/2 \\\\ 0 \u0026amp; r(n) \u0026lt; c + k/2 \\end{cases}$$    Sub-Sampling  Every bit is sent using many (SPB) samples. To recover the original bit sequence, we sub-sample the thresholded channel output once every SPB samples.  SUB-SAMPLE = take a subset of the samples   We sub sample near the end of the bit, to make sure the output is far above/below the threshold  Training Sequence In order to choose a threshold, the reciever needs to know c and k. However, these may change over time.\n To help the reciever estimate c and k the transmitter sends a training sequence.  Both the transmitter and reciever know the contents of the training sequence Thus the training sequence carries no new data We will use a very simple training sequence IRL, systems use more complicated sequences, but the idea remains the same. To help the reciever get information about the channel.    Our Training Sequence  Since the step response is a complete characterization of the channel, in our protocol, the transmitter will transmit a step-like waveform before any data. Assuming $F_s = 1 \\text{MHz}$, the training sequence consists of 500 microseconds of 0, followed by 500 microseconds of 1 then another 500 microseconds of 0.  Estimate of c = minimum value of the response Estimate of k = maximum - minimum    Length of Training Sequence  Trade off in the choice of pulse width:  Shorter pulse widths mean more time available to transmit data Longer pulse widths enable better estimate of channel parameters (c,k)   The choice of the pulse width is based on an assumption about the value of \u0026ldquo;a\u0026rdquo; in the step response. $s(n) = k(1-a^{n+1})u(n)$ If the value of \u0026ldquo;a\u0026rdquo; is larger (closer to 1), should the pulse be made larger or shorter? It should be longer. larger a means the channel changes slower.  Asynchronous Serial Communication Problem: Suppose the transmitter only sends information occasionally. If we receive a signal, it may be hard to decode a signal because we dont actually know when the signal started. It could have started with a bunch of 0s for example.\nAsynchronous Communication  In many communication systems. the transmitter and reciever are not synchronised. The reciever does not know when the transmitter will transmit data. This type of communication is known as an asynchronous link. In this type of link, the reciever needs a signal from the transmitter indicating when it starts to transmit data.  Framing  In asynchronous communication  data bits are first grouped into blocks The blocks are then framed   Framing bits  start bit - indicates the start of data transmission Stop bits - allow for time between transmission   The data block plus framing bits is called a frame  Start Bits  In order for the reciever to know the start of a transmitted bit sequence , we add a start bit before the bit sequence. The start bit is chosen to be either 0 or 1, depending on the normal recieved output of the idle channel In our channel, the output is normally low (0) so we choose the start bit to be 1  Data Block  For the reciever to know how long to listen, the transmitter and reciever must agree upon how many bits will follow the starter bit. We will refer to these bits as data block or character. In RS232 serial transmission used in PCs, there are usually 8 data bits following the start bit If the transmitter has too few bits to fill a block, we pad the block with zeroes If the transmitter has too many bits, we split the bits into multiple blocks.  Stop Bits  In order to enable the reciever to detect a new start bit after the end, we add one or more stop bits to the end. The stop bit chosen so that the recieved signal is the same as when the channel is idle Using more stop bits provides more time between data blocks. Giving the reciever more time to process the data block before it recieves the next frame, however it reduces the rate we can send information.  "});index.add({'id':5,'href':'/COMP4631/','title':"COMP4631 - Computer and Communication Security",'section':"Home",'content':"COMP4631 - Computer and Communication Security Cryptosystems, symmetric-key and public-key cryptography, cryptanalysis, authentication, message digests, digital signatures, and random number generation. Access controls and firewalls. Applications such as certificate authorities, electronic commerce, smartcards, and digital cash.\n  Examples of One-Key Block Ciphers   One-key Stram Ciphers; The Data Encryption Standard (DES); The Triple DES; Advanced Encryption Standard (AES); A Method for Padding Messages; The Cipher Block Chaining (CBC) Mode   One Key Block Ciphers   One key block ciphers and their security; Transposition Ciphers and their security; Simple substitution ciphers and their security; The one-time pad   Introduction to Cryptography   Data confidentiality, encryption; data integrity, authentication of sender and reciever; nonrepudiation; secret sharing; cryptographic protocols; history of cryptography   Discrete Math Review   Review on discete mathematics for cryptography.   Course Introduction and Physical Security   The content of the first two lectures. Laying down definitions, and the giving some scope on what is to be covered   "});index.add({'id':6,'href':'/COMP4631/05.-Examples-of-One-Key-Block-Ciphers/','title':"Examples of One-Key Block Ciphers",'section':"COMP4631 - Computer and Communication Security",'content':"One-key Stream Ciphers A 6-tuple $(\\mathcal M, \\mathcal C, \\mathcal K, E_k, D_k, u)$ where:\n $\\mathcal M, \\mathcal C, \\mathcal K$ are respectively the plaintext space, ciphertext space, and key space. Any $k \\in \\mathcal K$ could be the encryption and decryption key $u$ is a time-variable parameter stored in a memory device. $E_k$ and $D_k$ are encryption and decryption transformations with\n$D_k(E_k(m,u),u)=m,\\ \\forall m \\in \\mathcal M$  Remark: The ciphertext $c=E_k(m,u)$ depends on $k, m$ and $u$ and is time dependent, as $u$ is time-variable.\nDES in Brief  Block cipher with 56-bit long key Designed by IBM in 1976 for the National Bureau of Standards (NBS), with approval from the National Security Agency (NSA) Had been used as a standard for encryption until 2000. In 2001 a new encryption standard AES replaced DES Design ideas still used in most block ciphers  DES Encryption and Decryption  "});index.add({'id':7,'href':'/COMP4631/04.-One-Key-Block-Ciphers/','title':"One Key Block Ciphers",'section':"COMP4631 - Computer and Communication Security",'content':"One-Key Block Ciphers Defined as a 5-tuple $(\\mathcal M, \\mathcal C, \\mathcal K, E_k, D_k)$, where:\n $\\mathcal M$ is the plaintext space. $\\mathcal C$ is the ciphertext space. $\\mathcal K$ is the key space. Any $k \\in \\mathcal K$ could be the encrytption and decryption key. $E_k$ and $D_k$ are encryption and decryption transformations with\n$D_k(E_k(m)) = m,\\ \\forall m \\in \\mathcal M$  Direct Usage of One-Key Block Ciphers Given a block cipher $(\\mathcal M, \\mathcal C, \\mathcal K, E_k, D_k)$, encryption and decrytion is done as follows:\n Encryption: $c = E_k(m)$ where $E_k$ is usually applied to blocks or characters of the plaintext $m$ Decryption: $m = D_k(c)$, where $D_k$ is usually appled to blocks or characters of the ciphertext $c$  Classical Information Channel  Attacks on One-Key Block Ciphers Ciphertext-only Attack: A cryptanalyst determines the decryption transformation $D_k$ or key $k$, or plaintext from intercepted ciphertext $c$.\nKnown-Plaintext Attack: A cryptanalyst determines the decryption transformation $D_k$ or key $k$, from a ciphertext-plaintext pair $(c,m)$.\nSecurity Requirements for One-Key Block Ciphers  The security should depend on the confidentiality of the key, so it is usually assumed that the algorithms $E_k$ and $D_k$ are known to a cryptanalyst. It should be computationally infeasible for a cryptanalyst to determine the plaintext $m$, given a ciphertext $c$. It should be computationally infeasible for a cryptanalyst to determine the decryption trasnformation $D_k$ or key $k$ from intercepted ciphertext $c$, even if the corresponding plaintext $m$ is known  Permutations of $\\Bbb Z_d$ for Transposition Ciphers Let $\\Bbb Z_d$ denote the integers $0$ through $d-1$. A permutation $f$ of $\\Bbb Z_d$ is a one-to-one function from $\\Bbb Z_d \\to \\Bbb Z_d$.\nExample:\nLet $d = 4$ and define $f$ by\n  \\[\\begin{matrix} i \u0026amp; : \u0026amp; 0 \u0026amp; 1 \u0026amp; 2 \u0026amp; 3\\\\ f(i) \u0026amp; : \u0026amp; 2 \u0026amp; 0 \u0026amp; 3 \u0026amp; 1 \\end{matrix}\\]  Then $f$ is a permutation of $\\Bbb Z_4$. The inverse permutation $f^{-1}$ is\n \\[\\begin{matrix} i \u0026amp; : \u0026amp; 0 \u0026amp; 1 \u0026amp; 2 \u0026amp; 3\\\\ f^{-1}(i) \u0026amp; : \u0026amp; 1 \u0026amp; 3 \u0026amp; 0 \u0026amp; 2 \\end{matrix}\\]  Description of Transposition Ciphers Let $f$ be a permutation of $\\Bbb Z_d$. It is a 5-tuple $(\\mathcal M, \\mathcal C, \\mathcal K, E_k, D_k)$ where:\n $\\mathcal M = \\mathcal C = $ set of all finite strings of English letters. $\\mathcal K$ is the set of all possible pairs $(d,f)$. $k = (d,f) \\in \\mathcal K$ is the secret key A message is divided into blocks of lengths $d$, for each message block, $m = m_0 \u0026hellip; m_{d-1}$\n$$E_k(m) = m_{f(0)}\u0026hellip;m_{f(d-1)}$$ For each ciphertext block $c = c_0\u0026hellip;c_{d-1}$\n$$D_k(c)= c_{f^{-1}(0)}\u0026hellip;c_{f^{-1}(d-1)}$$  Example:\nLet $d=4$ and define $f$ by\n \\[\\begin{matrix} i \u0026amp; : \u0026amp; 0 \u0026amp; 1 \u0026amp; 2 \u0026amp; 3\\\\ f(i) \u0026amp; : \u0026amp; 2 \u0026amp; 0 \u0026amp; 3 \u0026amp; 1 \\end{matrix}\\]  The message $RENAISSANCES$ is broken in groups of 4 letters and transformed into:\n \\[\\begin{matrix} \\text{position} \u0026amp; 0123 \u0026amp; 0123 \u0026amp; 0123 \\\\ m \u0026amp; RENA \u0026amp; ISSA \u0026amp; NCES \\\\ E_k(m) \u0026amp; NRAE \u0026amp; SIAS \u0026amp; ENSC \\end{matrix}\\]  Yielding the ciphertext $NRAESIASENSC$. Decryption follows a similar process to encryption but using $f^{-1}$ mentioned in a previous example.\nDescription of Simple Substitution Ciphers Let $f$ be a one-to-one mapping from alphabet $A$ to alphabet $B$. It is a 5-tuple $(\\mathcal M, \\mathcal C, \\mathcal K, E_k, D_k)$, where:\n $\\mathcal M = A^{*}$ and $\\mathcal C = B^{*}$, i.e. all finite strings of characters. $\\mathcal K$ is the set of all possible $f$ $k = f \\in \\mathcal K$ is the encryption and decryption key. For a message $m = m_0m_1m_2\u0026hellip;$\n$$E_k(m) = f(m_0)f(m_1)f(m_2)\u0026hellip;$$ For a ciphertext $c = c_0c_1c_2\u0026hellip;$\n$$D_k(c) = f^{-1}(c_0)f^{-1}(c_1)f^{-1}(c_2)\u0026hellip;$$  Example:\nLet $A = B$ be the english alphabet. We identify letters with digits:\n \\[\\begin{matrix} a \u0026amp; b \u0026amp; c \u0026amp; ... \u0026amp; y \u0026amp; z \\\\ 0 \u0026amp; 1 \u0026amp; 2 \u0026amp; ... \u0026amp; 24 \u0026amp; 25 \\end{matrix}\\]  Take any $(k_0,k_1)$ with $\\gcd (k_0,26) = 1$ and $0 \\leq k_0 \\leq 25$, define the one-to-one mapping $f$ by\n$$f(a)= (ak_0 + k_1)\\mod 26$$\nIt is called the affine cipher, where $\\text{key } = (k_0,k_1) \\text{ or } k = f$.\nIf $k = (1,3)$ is it a caesar cipher.\nWeakness of Simple Substitution Ciphers Simple substitution ciphers are susceptible to frequency analysis of the letters.  \\[\\begin{matrix} A\u0026amp;B\u0026amp;C\u0026amp;D\u0026amp;E\u0026amp;F\u0026amp;G\u0026amp;H\u0026amp;I\u0026amp;J\u0026amp;K\u0026amp;L\u0026amp;M\\\\ 8.0\u0026amp;1.5\u0026amp;3.0\u0026amp;4.0\u0026amp;13.0\u0026amp;2.0\u0026amp;1.5\u0026amp;6.0\u0026amp;6.5\u0026amp;0.5\u0026amp;0.5\u0026amp;3.5\u0026amp;3.0\\\\ \u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\ N\u0026amp;O\u0026amp;P\u0026amp;Q\u0026amp;R\u0026amp;S\u0026amp;T\u0026amp;U\u0026amp;V\u0026amp;W\u0026amp;X\u0026amp;Y\u0026amp;Z\\\\ 7.0\u0026amp;8.0\u0026amp;2.0\u0026amp;0.2\u0026amp;6.5\u0026amp;6.0\u0026amp;9.0\u0026amp;3.0\u0026amp;1.0\u0026amp;1.5\u0026amp;0.5\u0026amp;2.0\u0026amp;0.2 \\end{matrix}\\]  Note: The numbers above represent percentages.\nThis table can be used to re-map letters back to its original self and obtain the plaintext.\nFrequency Distribution of Digraphs \u0026amp; Trigraphs  A digraph (also called a bigram) is a sequence of two english letters. A trigraph is a sequence of three english letters  The Most Frequent Digraphs:  th he in er an re on at at en nd ed or es ti te it is st to ar of ng ha al   The most Frequent Trigraphs  the and tha hat ent ion for tio has edt tis ers res ter con ing men tho    Redundancy in Human Language Redundancy in human language makes it easy for us to determine letters in places they may be missing. Shannon information theory can be used to give a rigorous measure of redundancy in human language.\nSecurity of Simple Substitution Ciphers  Simple substitution ciphers are not secure with respect to ciphertext-only attacks For english, about 28 letters in a piece of ciphertext are needed to break a simple substition cipher.  Are There Unbreakable Ciphers? Yes, the one-time-pad is an unbreakable cipher in the information-theoretic sense.\nOne Time Pad\n Each message is encoded into a binary string using the ascii code. The secret key is a random binary string with the same length as the message. The ciphertext is the bitwise XOR of the message with the secret key. A secret key is used only for one message then discarded.  "});index.add({'id':8,'href':'/COMP4631/03.-Introduction-to-Cryptography/','title':"Introduction to Cryptography",'section':"COMP4631 - Computer and Communication Security",'content':"Data Confidentiality Data in transmission or stored in a storage system could be very sensitive and only authorized people are allowed to read it. Data confidentiality means the prevention of unauthorized reading of data.\nHow to Achieve Data Confidentiality? By Encryption.\ni.e. Use a secret 1-1 mapping (function) $f$ to map a plaintext $m$ into a ciphertext $c$. $c = f(m)$.\nTo recover the plaintext $m$ from the ciphertext $c$, apply the inverse mapping $f^{-1}$ to $c$ yielding\n$$f^{-1}(c)=f^{-1}(f(m)) = (f^{-1} \\circ f)(m) = m$$\nThis process is called decryption.\nExamples of Encryption   Caesar Cipher  Pigpen Cipher  Data Integrity For data in transmission or stored in a storage system, the following could happen:\n It could be modified by an unauthorized person. It could be replaced with other data by an unauthorized person.  The problem then becomed how detect such modification and replacement of data.\nAuthenticity of Sender and Reciever Questions:\n If you recieved a message with alleged sender $X$, how could you be sure that the sender was indeed $X$? If you sent a message to a reciever $Y$, how could you be certain that $Y$ has recieved your message?  Nonrepudiation If I wrote a letter to you saying that I would pay you $1000000 if you finish a job for me, I cannot deny saying this because I would have signed the letter. Electronically, if you wanted to prove that I authored a message, the message would need to be signed by me.\nNonrepudiation is the assurance that someone cannot deny the validity of something.\nSecret Sharing Problem: A father has put a lot of treasure into a secure place that requires an electronic key $k$. He has three sons, to which he must share the key $k$ in such a way that the following conditions are satisfied:\n Each son has a share of the key which gives zero information about $k$. When any two of his sons come together with their shares, they still get no information about $k$. Only when all three of the sons are together with their shares shall the key recover $k$.  How could the father design such a scheme?\nCryptographic Protocols Problem: A group of banks would have an electric funds transfer system that does the following:\n Data confidentiality Data integrity Sender authentication nonrepudiation  Suppose that you have an algorithm for doing each of the above jobs. How do you combine these algorithms such that they work as a whole? Cryptographic Protocols.\nHistory of Cryptography  5000 year history Earlier called codes, encryption and decryption was done by hand. Ciphers were invented in about 1817 Played major roles in WWI WWII Modern cryptography started with Shannons paper: \u0026ldquo;Communication Theory os Secrecy Systems, Bell System Technical Journal 28 (1949) 656-715\u0026rdquo;  "});index.add({'id':9,'href':'/ELEC1200/Lecture4/','title':"Lecture4",'section':"ELEC1200 - A System View of Communications: from Signals to Packets",'content':"Linear Time Invariant Systems Systems  For this class, a system is something that takes a waveform $x(n)$ and produces an output waveform $y(n)$ e.g. a channel.  Linear Systems  A linear system is a system that satisfies the following two properties:  Homogeneity:\n$$x(n) \\to |\\text{ system }| \\to y(n) \\implies c \\cdot x(n) \\to |\\text{ system }| \\to c \\cdot y(n)$$  If you scale the input by $c$ times, the output is also scaled by $c$ times.   Additivity:\n  \\[\\begin{matrix} x_1(n) \\to |\\text{ system }| \\to y_1(n) \\\\ x_2(n) \\to |\\text{ system }| \\to y_2(n) \\end{matrix} \\implies x_1(n) \u0026#43; x_2(n) \\to |\\text{ system }| \\to y_1(n) \u0026#43; y_2(n)\\]   The output to the sum of two inputs is the sum of the outputs to each input considered individually.     Combining both properties, a linear system with a weighted sum of inputs $c_1 x_1(n) + c_2 x_2(n)$ gives the same weighted sum of the corresponding outputs $c_1 y_1(n) + c_2 y_2(n)$  Time Invariant Systems  A time invariant system is one where if you delay the input by $d$, you get the exact same output, just delayed by the same amount $d$.   Linear Time Invariant Systems (LTI)  A system that is both linear and time invariant is known as an LTI system Is the channel with attenuation, delay and offset an LTI system?  Step Response  If a system is LTI, then you can find the output just by knowing the output to any input function. For this course, we choose the unit step function as the input. The output to the unit step function is known as the systems step response. Which we indicate by $s(n)$.  Output of LTI Systems  Given the step response, to find the output to any input:  Write the input as the sum of scaled unit step functions Use homogeniety and time invariance Use additivity    Modelling the Channel Exponential Step Response  The exponential step response is a good model for the step responses of the communication channel in the labs. It can model:  Changes in amplitude (k) Propagation delay (d) Blurring of transitions (a)    $$s(n) = k(1-a^{n-d+1})u(n-d)$$\n Transmission Over a Channel  The signal at the reciever is the sum of two parts:  The response to the input, which can be computed from the step response according to the LTI assumptions. Signals, such as offset (c) and noise that are introduced from the environment (e.g. other users)    Response to Unit Step  The response of a communication channel can be modelled by a function of multiple variables.  $$y(n) = c + k(1-a^{n+1-d})u(n-d)$$\n $c$ - offset $k$ - amplitude $d$ - delay a - base of exponential  "});index.add({'id':10,'href':'/ELEC1200/Lecture3/','title':"Lecture3",'section':"ELEC1200 - A System View of Communications: from Signals to Packets",'content':"Representing Bit Waveforms Equivalent Representations of Waveforms  Verbal: The encoding of the bit sequence $1010001$ at 4 samples per bit. Graph:\n List, Table or Vector of Values:\n$n = [0, 1, 2, 3, \u0026hellip;]$\n$x(n) = [1, 1, 1, 0, \u0026hellip;]$ Sum of Unit Step Functions:\n$x(n) = u(n) - u(n-4) + u(n-8) + \u0026hellip; + u(n + m)$  Uses for Different Representations  The four representations are equivalent in that if we know one, we can obtain any of the others. However they are useful in different situations. Verbal is useful for communicating between people List, Table or vector is useful for representation and processing within a computer Sum of unit step functions is useful for analyzing mathematically what happens to the waveform when it passes through a communication channel.  Functions to Specify Waveforms   Graphs are intuitve ways to specify waveforms.\n  But to do analysis, we need to use formulas that give the value of the waveform $x$ for any sample $n$.\n  One possibility\n  \\[x(n) = \\begin{cases} 1 \u0026amp; 0 \\leq n \u0026lt; 4 \\\\ 0 \u0026amp; 4 \\leq n \u0026lt; 8 \\\\ \\vdots \u0026amp; \\vdots \\\\ b_k \u0026amp; k \\cdot \\text{SPB} \\leq n \u0026lt; (k \u0026#43; 1) \\cdot \\text{SPB} \\\\ \\vdots \u0026amp; \\vdots \\end{cases}\\]    However it is difficult to work with this formula. We seek a better way using the unit step function.\n  Unit Step Function  In order to get a better formula to define a bit waveform, we define the unit step function $u(n)$\n \\[u(n) = \\begin{cases} 0 \u0026amp; n \u0026lt; 0 \\\\ 1 \u0026amp; 0 \\leq n \\end{cases}\\]    We can delay the step function as follows:\n \\[u(n-d) = \\begin{cases} 0 \u0026amp; n \u0026lt; d \\\\ 1 \u0026amp; d \\leq n \\end{cases}\\]  Combining Step Functions  We can describe a single pulse as the difference between two step functions.\n  Representing Bit Waveforms  We can describe any bit sequence as the sum and difference of unit step functions One step function every time a bit changes  If the bit changes from 0 to 1 at sample $D$, add $u(n-D)$ If the bit changes from 1 to 0 at sample $D$, subtract $u(n-D)$ If there is no change, add nothing.    The Discrete Time Channel Communication System  Transmitter encodes information as a physical waveform. The physical waveform travels over a medium (e.g. air) which modifies the waveform as it passes. This medium is called the channel. The reciever must take this modified waveform and try to figure out the original information.\n  Discrete Time Channel  Modern communication systems are built from computers that work in discrete time, but most channels are in continuous time. Thus modern transmitters create discrete time signals, and then generate continuous time signals to send. Modern recievers recieve continuous time signals, which they sample to obtain discrete time signals. In the context of thus course, we do not care about the conversion from/to discrete/continuous, and thus will treat the mapping from the transmitted samples $x(n)$ to the recieved samples as a black box, called a discrete time channel.  Mathematical Models  A mathematical model describes the operation of a system using mathematical formulas. Given a formula for the input, how do we get a formula for the output. We have a good model if:  The model and actual response are similar, $y_m(n) \\approx y_a(n)$ The relationship between $y_m(n)$ and $x(n)$ is simple. i.e. easy to understand and calculate.    Engineers use models to  Understand the operation of the system  What is the relationship between the input and output of the channel?   Predict the performance of a system Develop modifications to the system that can improve performance  Effects of the Channel Possible Effects of the Channel The channel may cause the recieved signal $y(n)$ to differ from the transmitted signal $x(n)$ in several ways including:\n Attenuation Delay Offset Blurring of Transitions Noise  This course focuses on the first four listed above.\nModelling Attenuation, Delay, and Offset  $k = \\text{ attenuation } (k \u0026lt; 1)$ $d = \\text{ delay}$ $c = \\text{ offset}$  Mathematical Model\n$$y(n) = k \\cdot x(n-d) + c$$\nBlurring of Transitions  The bit sequence is encoded by a waveform that makes instantaneous changes from one value (1) to another (0). Due to physical limitations in the:  Transducer that creates the physical waveform Electronics that drive the transducer Physical medium that carries the waveform Sensor that senses the physical waveform Electronics that process the sensor signal    The actual recieved waveform cannot make instantaneous changes.\n In engineering terms, we say that the channel is bandlimited.  Developing a Bandlimited Channel Model  Can we develop a mathematical model that enables us to predict the output of a bandlimited channel from any input? Yes, if we assume the channel is linear and time invariant. We will use the fact that any input can be expressed as the sum of unit step functions.  Summary  Discrete Time Channel:  Discrete waveform Represent bit sequences as bit waveform   Effect of the Channel:  Possible effects of the channel:  Attenuation (decrease in amplitude) Delay Offset Blurring of transitions Noise      "});index.add({'id':11,'href':'/ELEC1200/Lecture2/','title':"Lecture2",'section':"ELEC1200 - A System View of Communications: from Signals to Packets",'content':"Recap of Lecture 1 Representing Bit Sequences as Waveforms  A bit sequence can be encoded by changing the value of a physical variable over time Each bit is encoded by holding the state constant over a length of time known as the bit time. The shorter the bit time, the faster we can transmit information (bits).  Encoding information with Bits Bits  A bit is the basic unit of information used in modern computers and communication systems. A bit is a variable that can assume one of two values or \u0026ldquo;states\u0026rdquo;. Commonly denoted as $0$ or $1$. Can be thought of as the answer to a yes/no question. Variables that can assume more than two values can still be represented by conbinations or sequences of bits. Example:  binary numbers ASCII    Sequence of Yes/No Questions A binary number can also be thought of as the answer to a series of yes/no (1/0) questions. For example if $N=3$,\n Binary Digits  We can use N bits $b_{N-1}, b_{N-2}, \u0026hellip;, b_1, b_0$ to represents integers from $0$ to $2^N -1$. Each digit is the sum of powers of two  $$x = \\sum_{i=0}^{N-1} 2^i \\cdot b_i$$\n Notation:  $b_{N-1}$ is the most significant bit (MSB). $b_0$ is the least significant bit (LSB).    ASCII Codes  ASCII = American Standard Code for Information Interchange An 8-bit code used to represent text symbols.   See this\nBit Sequences  Information we want to send is typically encoded as long bit sequences created by concatenating binary code words.  Continuous vs Discrete Time Waveforms  A continuous time (CT) signal has a known value for all points in a time interval. A discrete time (DT) signal has a known value only at a discrete (discontinuous) set of time points.  Sampling: From Continuous to Discrete  We can obtain discrete time waveforms by sampling (recording) a continuous time waveform $x_c(t)$ at regular intervals in time.  $T_s$ = Sample Period   We typically index (identify, label) each sample by an integer sample number, $n$. We denote the sampled waveform by $x(n)$ The $n$th corresponds to the waveform at the time $t = nT_s$. i.e. $x(n) = x_c(nT_s)$  From Discrete to Continuous Time  Given samples $x(n)$, we can obtain a continuous time waveform $x_h(t)$ by holding the waveform at $x(n)$ between times $nT_s$ and $(n+1)T_s$  Sampling Period vs Frequency  $T_s$ = Sample Period (time interval between samples)  Typical unit: Seconds (s)   $F_s$ = Sampling frequency (number of samples in a fixed period of time)  Typical unit: Hertz (Hz samples per second)   Relation: $$F_s = \\frac{1}{T_s}$$  Example:\n$T_s = 0.2$ seconds\n$F_s = \\frac{1 \\text{ sample}}{0.2 \\text{ seconds}} = 5 Hz$\nNumber of Samples   If we sample a signal at intervals of $T_s$ over a finite time window $T_w$, we obtain $N$ samples where\n$$N = \\frac{T_w}{T_s} = T_w \\cdot F_s$$\n  This is an example of an engineering tradeoff: A higher sample frequency is:\n Good: Less information lost since less time between samples Bad: More storage is needed since more samples for a given length of time.    Discrete Time Bit Waveforms From Bit Sequences to Bit Waveforms  Bits can be encoded by holding a physcial variable constant over a \u0026ldquo;bit time\u0026rdquo; In discrete time, we encode bits as waveforms by holding sample values constant over a number of Samples Per Bit (SPB).  Bit Rate, Sampling Frequency, SPB   The bit time measures the length of time it takes to send one bit.\n $\\text{bit time } = \\text{SPB} \\cdot T_s = \\frac{\\text{SPB}}{F_s}$    The bit rate measures the number of bits we can send in a given unit of time.\n $\\text{bit rate } = \\frac{1}{\\text{bit time}} = \\frac{1}{\\text{SPB} \\cdot T_s} = \\frac{F_s}{\\text{SPB}}$    We generally want:\n The bit rate to be large The bit time to be small    "});index.add({'id':12,'href':'/COMP4631/02.-Discrete-Math-Review/','title':"Discrete Math Review",'section':"COMP4631 - Computer and Communication Security",'content':"Discrete Mathematics Review  Sets A set is a collection of distinct objects.  Members and Elements  The objects that make up a set are called members or elements of the set. An object is anything that is \u0026ldquo;meaningful\u0026rdquo;. For example: a number, equation, other sets, etc\u0026hellip;  Equality of Sets  Two sets are equal if and only if they have the same members. That is, a set is completely determined by its members. This is the principle of extension.  Set Notation A set can be described by listing comma seperated members within curly braces\nExample:\nLet $S = \\{1,3,9\\}$\n$S$ is a set, and $1,3,9$ are its members.\n It is important to note that order and repetition do not matter in sets. That is, $\\{1,3,9\\}$ is equivalent to $\\{9,1,3\\}$ and $\\{1,1,1,1,9,9,9,9,3,9,3\\}$. They all denote a set whose members are $1, 3, \\text{and} \\space 9$.\nThe Membership Symbol $\\in$  The fact that $x$ is a member of $S$ can be expressed as $x \\in S$. The membership symbol $\\in$ can be read as \u0026ldquo;is in\u0026rdquo;, \u0026ldquo;is a member of\u0026rdquo;, or \u0026ldquo;belongs to\u0026rdquo;. The negation of $\\in$ is $\\not\\in$  Example:\nLet $S = \\{7,13,21,47\\}$, then $7 \\in S, 13 \\in S, 21 \\in S, 47 \\in S, 56 \\not\\in S$.\nDefining a Set by Membership Properties $$S = \\{x \\in T \\space| \\space P(x)\\}$$ The members of $S$ are members of an already known set $T$ that satisfy property $P$.  Example:\n Let $\\Bbb Z$ be the set of integers. Let $\\Bbb Z_+$ be the set of positive integers. Then $\\Bbb Z_+ = \\{x \\in \\Bbb Z \\space | \\space x \u0026gt; 0\\}$  The Empty Set and Sets of Numbers The Empty Set  The empty set is also called the null set. It is a set with no members. It is denoted as $\\emptyset$. Thus $\\{\\} = \\emptyset$ For any object $x, x\\not\\in \\emptyset$.  The Sets of Positive, Negative, and All Integers  $\\Bbb Z$ is the set of all integers.  $\\Bbb Z = \\{\u0026hellip;, -2, -1, 0, 1, 2, \u0026hellip;\\}$   $\\Bbb Z_+$ is the set of all positive integers.  $\\Bbb Z_+ = \\{1,2,3,\u0026hellip;\\} = \\{x\\in \\Bbb Z \\space | \\space x \u0026gt; 0\\}$   $\\Bbb Z_-$ is the set of all negative integers.  $\\Bbb Z_- = \\{\\space\u0026hellip;,-3,-2,-1\\} = \\{x\\in \\Bbb Z \\space | \\space x \u0026lt; 0\\}$    The set of Real Numbers and Rational Numbers  $\\Bbb R$ is the set of all real numbers. $\\Bbb Q$ is the set of all rational numbers. $\\Bbb Q = \\{x \\in \\Bbb R \\space | \\space x = p/q; \\space p,q \\in \\Bbb Z; \\space q \\not = 0\\}$  Subsets and Power Sets Subsets ($\\subset, \\subseteq$) $A$ is a subset of $B$, or $B$ is a superset of $A$ if and only if every member of $A$ is a member of $B$  Notation:\n$$A \\subseteq B \\text{ iff } \\space \\forall x, x \\in A \\implies x \\in B$$\nExample:\n$$\\{-2,0,8\\} \\subseteq \\{-3,-2,-1,0,2,4,6,8,10\\}$$\nNegation of $\\subseteq$ $A$ is not a subset of $B$, or $B$ is not a superset of $A$ if and only if there is a member of $A$ that is not a member of $B$  Notation:\n$$A \\not \\subseteq \\text{ iff } \\space \\exists x, x \\in A \\text{ and } x \\not \\in B$$\nExample:\n$$\\{2,4\\} \\not \\subseteq \\{2,3\\}$$\nObvious Subsets  $S \\subseteq S$ $\\emptyset \\subseteq S$  Vacuously true: $\\text{if } x \\in \\emptyset \\implies x \\in S$ By contradiction: $\\text{if } \\emptyset \\not \\subseteq S \\implies \\exists x, x \\in \\emptyset \\text{ and } x \\not \\in S$    Proper Subsets $\\subset$ $A$ is a proper subset of $B$, or $B$ is a proper superset of $A$ if and only if $A$ is a subset of $B$ and $A$ is not equal to $B$.  Notation:\n$$A \\subset B \\text{ iff } A \\subseteq B \\text{ and } A \\not = B$$\nExamples:\n$$S \\not = \\emptyset \\implies \\emptyset \\subset S$$\n$$\\Bbb Z_+ \\subset \\Bbb Z \\subset \\Bbb Q \\subset \\Bbb R$$\nPower Sets The set of all subsets of a set is called the power set of the set.\nThe power set of $S$ is $P(S)$\n Examples:\n $P(\\emptyset) = \\{\\emptyset\\}$ $P(\\{1,2\\}) = \\{\\emptyset, \\{1\\}, \\{2\\}, \\{1,2\\}\\}$ $P(S) = \\{\\emptyset, \u0026hellip;, S\\}$  $\\in$ and $\\subseteq$ are different!\nExamples:\n $1 \\in \\{1\\}$ is true. $1 \\subseteq \\{1\\}$ is false. $\\{1\\} \\subseteq \\{1\\}$ is true.   Questions  Which of the following statements is true?  $S \\subseteq P(S)$ $S \\in P(S)$   What is $P(\\{1,2,3\\})$?   Answers ↕   $S \\in P(S)$ $P(\\{1,2,3\\}) = \\{\\emptyset, \\{1\\}, \\{2\\}, \\{3\\}, \\{1,2\\}, \\{1,3\\}, \\{2,3\\}, \\{1,2,3\\}\\}$     Equality of Sets by Mutual Inclusion Sets $A$ and $B$ have the same members if and only if they mutually include. Meaning, $A \\subseteq B \\text{ and } B \\subseteq A$.\nThat is, $A = B \\text{ iff } A \\subseteq B \\text{ and } B \\subseteq A$\n Mutual inclusion is very useful for proving the equality of two sets. To prove and equality, we prove two subset relationships.\nExample Showing the Equality of Sets:\n Recall that $\\Bbb Z$ is the set of all integers. Let $A = \\{x \\in \\Bbb Z \\space | \\space x = 2m \\space \\text{for some } m \\in \\Bbb Z \\}$ Let $B = \\{y \\in \\Bbb Z \\space | \\space y = 2n-2 \\space \\text{for some } n \\in \\Bbb Z\\}$ To show that $A \\subseteq B$, note that  $2m = 2(m+1)-2 = 2n-2$   To show that $B \\subseteq A$, note that  $2n-2 = 2(n-1) = 2m$   That is, $A=B$ Both $A$ and $B$ denote the set of even integers.  Exercise:\n Let  $A = \\{x \\in \\Bbb Z \\space | \\space x^2 -1 = 0\\}$ $B = \\{x \\in \\Bbb Z \\space | \\space 2x^3 - x^2 -2x +1 = 0\\}$    Show that $A = B$ by the method of mutual inclusion.\n Potential Answer ↕   To show that $A \\subseteq B$:  $x^2 -1 = 0 \\implies x = \\pm 1$ $\\because x = \\pm 1, \\space x^3 = x$ $\\forall n \\in \\Bbb R, \\space n - n = 0$ $\\text{From (2) and (3), } \\space x^2-1=0 \\implies -(x^2-1) + (2x^3-2x) = 0$ $\\therefore x^2-1 = 0 \\implies 2x^3-x^2-2x+1=0$   To show that $B \\subseteq A$:  $2x^3-x^2-2x+1=0$ $2x(x^2-1)-(x^2-1)=0$ $(2x-1)(x^2-1)=0$ $\\because x \\in \\Bbb Z, \\space (2x-1)(x^2-1) = 0 \\implies (x^2-1) = 0$    $\\therefore A = B$    Universal Sets, Venn Diagrams Universal Sets  Depending on the context of discussion:  Define a set $\\Bbb U$ such that all sets of interest are subsets of $\\Bbb U$. The set $\\Bbb U$ is known as a universal set.     Example:\n When dealing with integers, $\\Bbb U$ may be $\\Bbb Z$. When dealing with plane geometry, $\\Bbb U$ may be the set of all points in the plane.  Venn Diagrams  Used to visualize relationships among some sets Each subset of $\\Bbb U$ is represented by a circle/oval inside of a rectangle.   Set Operations Let $A, B$ be subsets of some universal set $\\Bbb U$.\nThe following set operations create new sets from $A$ and $B$:\n Union  $A \\cup B = \\{x \\in \\Bbb U \\space | \\space x \\in A \\text{ or } x \\in B\\}$ Example: $$\\{1,2,3\\} \\cup \\{2,3,4,5\\} = \\{1,2,3,4,5\\}$$   Intersection  $A \\cap B = \\{x \\in \\Bbb U \\space | \\space x \\in A \\text{ and } x \\in B\\}$ Example: $$\\{1,2,3\\} \\cap \\{2,3,4,5\\} = \\{2,3\\}$$   Difference  $A - B = A \\backslash B = \\{x \\in \\Bbb U \\space | \\space x \\in A \\text{ and } x \\not \\in B\\}$ Example: $$\\{1,2,3\\} - \\{2,3,4,5\\} = \\{1\\}$$   Complement  $A^c = \\Bbb U - A = \\{x \\in \\Bbb U \\space | \\space x \\not \\in A\\}$    Venn Diagram Visualization Union  Intersection  Difference  Complement   Set Identities  Commutative Laws:  $A \\cup B = B \\cup A$ $A \\cap B = B \\cap A$   Associative Laws:  $(A \\cup B) \\cup C = A \\cup (B \\cup C)$ $(A \\cap B) \\cap C = A \\cap (B \\cap C)$   Distributive Laws:  $A \\cup (B \\cap C) = (A \\cup B) \\cap (A \\cup C)$ $A \\cap (B \\cup C) = (A \\cap B) \\cup (A \\cap C)$   $\\emptyset$ is the identity for union:  $\\emptyset \\cup A = A \\cup \\emptyset = A$   $\\Bbb U$ is the identitiy for intersection:  $A \\cap \\Bbb U = \\Bbb U \\cap A = A$   Double Complement Law:  $(A^c)^c = A$   Idempotent Laws:  $A \\cup A = A$ $A \\cap A = A$   De Morgan\u0026rsquo;s Laws:  $(A \\cup B)^c = A^c \\cap B^c$ $(A \\cap B)^c = A^c \\cup B^c$    Questions  What is $(A \\cap B) \\cap (A \\cup B)$? What is $(A \\cup B) \\cup (A \\cap B)$?   Answers ↕   $A \\cap B$ $A \\cup B$     Other Useful Notation and Definitions The Number of Elements in a Set The number of elements in set $A$ is defined to be $\\vert A \\vert$\nExample:\n$\\vert A \\vert = \\vert \\{x,y,z\\} \\vert = 3$\nCartesian Product of Sets The cartesian product of two sets is defined as $$ A \\times B = \\{ (a,b): a \\in A, b \\in B\\} $$  $$A \\times B \\text{ is not always the same as } B \\times A$$  Example:\nLet $A = \\{x,y,z\\}$ and $B = \\{1,2\\}$ then\n$$A \\times B = \\{(x,1),(x,2), (y,1), (y,2), (z,1), (z,2)\\}$$\n Functions From High School Functions to General Functions High School Functions Functions are usually given by formulas such as $f(x) = \\sin (x)$ or $f(x) = e^x$, etc\u0026hellip;\nA function is a computation rule that changes one value to another. Effectively associating or relating one value to another.\nGeneral Functions Since a function relates one value to another, we can think of a function as relating one object to another object. These objects dont necessarily need to be numbers.\nUsually, we want to be able to relate each object of interest to only one object. That is, a function is a single-valued and exhaustive relation.\n A relation $f$ from $A$ to $B$ is a function from $A$ to $B$ if and only if:  For every $x \\in A$, there exists a unique $y \\in B$ such that $x\\ f\\ y$, or equivalently $(x,y) \\in f$   Functions are also known as transformations, maps and mappings.   Examples:\nLet $A = \\{1,2,3\\} \\text{ and } B = \\{a,b\\}$\n$R = \\{(1,a), (2,a), (3,b)\\}$ is a function from $A$ to $B$. Let $A = \\{1,2,3\\} \\text{ and } B = \\{a,b\\}$\n$S = \\{(1,a), (1,b), (2,a), (3,b)\\}$ is not a function from $A$ to $B$. Let $A = \\{1,2,3\\} \\text{ and } B = \\{a,b\\}$\n$T = \\{(1,a), (3,b)\\}$ is not a function from $A$ to $B$. Function Notation  Let $f$ be a relation from $A$ to $B$. That is, $f \\subseteq A \\times B$ If the relation is a function:  We write $f: A \\to B$ If $(x,y) \\in f$, we write $y = f(x)$   Usually $f,g,h,\u0026hellip;$ are used to denote relations that are functions.   Notational Convention Sometimes functions are given by stating the rule of transformation. For example, $f(x) = x + 1$. This should be taken to mean:\n$$f = \\{(x,f(x)) \\in A \\times B \\ | \\ x \\in A \\}$$\nWhere $A$ and $B$ are some understood sets.\nValues, Images, Inverse Images, Pre-Images Values, Images Let $f: A \\to B$\nLet $y = f(x)$ or $(x,y) \\in f$\nThe object $y$ is called:\n The image of $x$ under the functions $f$. The value of $f$ at $x$.  Inverse Images, Pre-Images Let $f: A \\to B \\text{ and } y \\in B$\nDefine $f^{-1}(y) = \\{x \\in A | f(x) = y\\}$\nThe set of $f^{-1}(y)$ is called the inverse image , or pre-image of $y$ under $f$.\nImages and Pre-Images of Subsets Let $f: A \\to B \\text{ and } X \\subseteq A \\text{ and } Y \\subseteq B$\nWe define:\n $f(X) = \\{f(x) \\in B \\ | \\ x \\in X\\}$ $f^{-1}(Y) = \\{x \\in A \\ | \\ f(x) \\in Y\\}$  Some Properties  Let $f: A \\to B \\text{ and } X \\subseteq A \\text{ and } Y \\subseteq B$ $f(A) \\subseteq$ B $f^{-1}(B) = A$ because every element of $A$ has an image in $B$.  Questions  Let $f: A \\to B \\text{ and } X \\subseteq A \\text{ and } Y \\subseteq B$   If there are $n$ elements in $X$, how many elements are there in $f(X)$? If there are $n$ elements in $Y$, how many elements are there in $f^{-1}(Y)$?   Answers ↕   The number of elements in $f(X)$ could be any integer between $1$ and $n$. The number of elements in $f^{-1}(Y)$ cannot be determined.     Codomains, Domains, Ranges Domains  Let $f: A \\to B$  The domain of function $f$ is the set $A$.  Codomains and Ranges  Let $f: A \\to B$  The codomain of function $f$ is the set $B$.\nThe range of function $f$ is the set of images of $f$. Clearly, the range of $f$ is $f(A)$.\n Example:\n Consider $\\exp: \\Bbb R \\to \\Bbb R$. That is, $\\exp(x) = e^x$. The domain and codomain are both $\\Bbb R$, but the range of $\\exp$ is $\\Bbb R_+$, the set of positive reals.  Sets of Images and Pre-Images Images and Pre-Images of Subsets  Let $f:A \\to B$. Let $X, X^\\prime \\subseteq A \\text{ and } Y, Y^\\prime \\subseteq B$. We shall call $f(X)$ the image of $X$ instead of the set of images of members $X$. Similarly, we shall simply call $f^{-1}(Y)$ the pre-image of $Y$. We have:  $f(f^{-1}(Y)) \\subseteq Y \\text{ and } X \\subseteq f^{-1}(f(X))$  It is possible to have strict inclusion when the range of $f$ is a proper subset of its codomain, we may take $Y = B$ to obtain $f(f^{-1}(B)) = f(A) \\subset B$   $f(X \\cup X^\\prime) = f(X) \\cup f(X^\\prime), \\ f(X \\cap X^\\prime) \\subseteq f(X) \\cap f(X^\\prime)$  $\\because X \\cup X^\\prime \\supseteq X, f(X \\cup X^\\prime) \\supseteq f(X)$ $\\text{Likewise we have } f(X \\cup X^\\prime) \\supseteq f(X^\\prime)$ $\\therefore f(X \\cup X^\\prime) \\supseteq f(X) \\cup f(X^\\prime)$ $\\text{To show that } f(X \\cup X^\\prime) \\subseteq f(X) \\cup f(X^\\prime), \\text{ let } y \\in f(X \\cup X^\\prime)$ $\\exists x \\in X \\cup X^\\prime \\text{ such that } f(x) = y$ $x \\in X \\implies y \\in f(X); \\text{ otherwise, } y \\in f(X^\\prime)$ $\\therefore y \\in f(X) \\cup f(X^\\prime)$ That is, $f(X \\cup X^\\prime) \\subseteq f(X) \\cup f(X^\\prime)$   $f^{-1}(Y \\cup Y^\\prime) = f^{-1}(Y) \\cup f^{-1}(Y^\\prime)$ $f^{-1}(Y \\cap Y^\\prime) = f^{-1}(Y) \\cap f^{-1}(Y^\\prime)$    Equality of Functions  Let $f:A \\to B \\text{ and } g: C \\to D$ We define function $f = $ function $g$ if and only if set $f = $ set $g$ Note that this forces $A = C$ but allows $B \\not = D$. Some still require $B = D$.   Proof That Set $f = $ Set $g \\implies $ Domain $f = $ Domain $g$  $\\text{Let } f:A \\to B \\text{ and } g:C \\to D \\text{ and set } f = \\text{ set }g$ $\\text{Let } x \\in A$  $(x, f(x)) \\in f$ $\\text{But } f = g \\text{ as sets.}$ $(x,f(x)) \\in g$ $\\text{That is, } x \\in C$ $\\text{Consequently, } A \\subseteq C$   $\\text{Similarly, we have } C \\subseteq A$ $\\text{That is, } A = C$  Proof That Set $f = $ Set $g \\implies f(x) = g(x)$ for all $x \\in A$  $\\text{Let } f,g: A \\to B \\text{ and set } f = \\text{ set }g$ $\\text{Let } x \\in A$  $(x,f(x)) \\in f$ $\\text{But } f=g \\text{ as sets.}$ $(x,f(x)) \\in g$ $\\text{That is, } (x,f(x)), (x,g(x)) \\in g$ $\\text{Since $g$ is a function, so } f(x) = g(x)$    Some Special Functions Identity Functions $I_A(a) = a$ for every element $a \\in A$   Consider the identity relation $I_A$ on the set $A$. For every $x \\in A, \\ I_A$ relates $x$ to a unique element of $A$ that is itself. Consequently we have $I_A: A \\to A$ $I_A$ is also called the identity function on $A$ The inverse of $I_A$ is itself.  Permutations A permutation $f$ of $A$ is a one-to-one correspondence from $A \\to A$   Every permutation $f$ of $A$ has the inverse $f^{-1}$. Which is also a permutation of $A$.  Permutations as 1D Arrays Any permutation of $A = \\{1,2,\u0026hellip;,n\\}$ can be expressed as an array.\n$$ \\begin{matrix} f[1] \u0026amp; f[2] \u0026amp; \u0026hellip; \u0026amp; f[n] \\end{matrix} $$\nPermutations as 2D Arrays Let $A = {1,2,\u0026hellip;,n}$. If $n = lm$, then a permutation $f$ of $A$ can also be defined as a two dimensional array\n  \\[\\begin{matrix} f[1] \u0026amp; f[2] \u0026amp; \\cdots \u0026amp; f[l] \\\\ f[1\u0026#43;l] \u0026amp; f[2\u0026#43;l] \u0026amp; \\cdots \u0026amp; f[2l] \\\\ f[1\u0026#43;2l] \u0026amp; f[2\u0026#43;2l] \u0026amp; \\cdots \u0026amp; f[3l] \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ f[1\u0026#43;(m-1)l] \u0026amp; f[2\u0026#43;(m-1)l] \u0026amp; \\cdots \u0026amp; f[ml] \\end{matrix}\\]  Constant Functions  $\\text{Let } f: A \\to B$ $\\text{If } f(A) = \\{y\\} \\text{ for some } y \\in B \\text{, $f$ is called a constant function of value }y$  Characteristic Functions  Consider some universal set $\\Bbb U$ Let $A \\in \\Bbb U$ The function $\\mathcal X_A: \\Bbb U \\to \\{0,1\\}$ is defined by:  $\\mathcal X_A(x) = 1 \\text{ if } x \\in A$ $\\mathcal X_A(x) = 0 \\text{ if } x \\in A^c$ And is called the characteristic function of A    Unary and Binary Operations as Functions Unary Operations  A unary operation on a set $A$ acts on an element of $A$ and produces another element of $A$. A unary operation $\\text{uop}$ can be thought of as a function $f:A \\to A$ with $f(x) = \\text{uop}(x)$. Conversely, a function from $A \\to A$ can be regarded as a unary operation on $A$.   Binary Operations  A binary operation on a set $A$ acts on two elements of $A$ and produces another element of $A$. Binary operation $\\text{bop}$ can be represented as a function  $f: A \\times A \\to A \\text{ with } f((a,b)) = a \\text{ bop } b$   We write $f(a,b)$ instead of $f((a,b))$ Conversely, from $A \\times A \\to A$ can be regarded as a binary operation on $A$   The Composition of Two Functions is a Function  Let $f: A \\to B \\text{ and } g:B \\to C$ Relations can be composed. Because functions are also relations, then functions can also be composed. So relations $f$ and $g$ can be composed, and their composition is $g \\circ f$ $g \\circ f$ is a relation from $A \\to C$  Funtion Composition gives a Function  Let $f: A \\to B \\text{ and } g:B \\to C$ We want to show that $g \\circ f : A \\to C$. That is, the composition of two functions is a function. We have to show that for any $x \\in A$, there is a unique $z \\in C$ such that $(x,z) \\in g \\circ f$  Existency Proof  $\\text{Let } x \\in A$ $\\text{Since $f$ is a function from $A \\to B$, there is a unique $y \\in B$ such that $(x,y) \\in f$}$ $\\text{For this $y \\in B$, there is a unique $z \\in C$ such that $(y,z) \\in g$}$ $\\text{ because $g$ is a function from } B \\to C$ $\\text{That is, $(x,z) \\in g \\circ f$}$  Uniqueness Proof  $\\text{Let } (x,z), (x,z^\\prime) \\in g \\circ f$ $\\text{There exist } y, y^\\prime \\in B \\text{ such that }$  $(x,y) \\in f, \\ (y,z) \\in g$ $(x, y^\\prime) \\in f, \\ (y^\\prime , z^\\prime) \\in g$   $\\text{But $f$ is a function, so } y = y^\\prime$ $\\text{Now we have } (y,z), (y, z^\\prime) \\in g$ $\\text{But $g$ is a function, so }z = z^\\prime$  The Values of Function Composition For Compositions of Two Functions  $\\text{Let } f: A \\to B \\text{ and } g: B \\to C$ $\\text{Since } g \\circ f: A \\to C \\text{, for any $x \\in A$, there is a } z \\in C, \\text{ such that } g \\circ f(x) = z$ $\\text{That is, } (x,z) \\in g \\circ f$ $\\text{By the definition of function composition, there is a } y \\in B \\text{, such that } (x,y) \\in f \\text{ and } (y,z) \\in g$. $\\text{Since $f$ and $g$ are functions, we can write } f(x) = y \\text{ and } g(y) = z$ $\\text{Substituting } y = f(x) \\text{ in } g(y) = z \\text{, we have } g(f(x)) = z$ $\\text{That is, } g \\circ f(x) = g(f(x))$  For Compositions of Three Functions  $\\text{Let } f: A \\to B, \\ g: B \\to C, \\ h: C \\to D$ $\\text{Since relation composition are associative and functions are relations, } h \\circ (g \\circ f) = (h \\circ g) \\circ f$ Furthermore we have:  $(h \\circ (g \\circ f))(x) = h((g \\circ f)(x)) = h(g(f(x)))$ $((h \\circ g) \\circ f)(x) = (h \\circ g)(f(x)) = h(g(f(x)))$   $\\text{That is, } (h \\circ (g \\circ f))(x) = ((h \\circ g) \\circ f)(x) = h(g(f(x)))$  One-To-One Functions, Injections  Let $f: A \\to B$ The function $f$ is only one-to-one if and only if:  for any $x,x^\\prime \\in A$ $f(x) = f(x^\\prime) \\implies x = x^\\prime$ Equivalently, $x \\not = x^\\prime \\implies f(x) \\not = f(x^\\prime)$   In words, a function is one-to-one if and only if it maps distinct elements to distinct images. A one-to-one functions is also called an injection We abbreviate one-to-one as 1-1.   Example:\n $\\text{Let }f:\\Bbb Z \\to \\Bbb Z \\text{ with } f(x) = x^2$ $f \\text{ is not 1-1 because }f(x) = f(-x)$  Composition of One-To-One Functions Theorem  $\\text{Let }f:A \\to B, \\ g:B \\to C$ $\\text{If both $f$ and $g$ are 1-1 then } g \\circ f \\text{ is also 1-1.}$ That is, the composition of 1-1 functions is 1-1.   Proof:\n $\\text{Let } (g \\circ f)(x) = (g \\circ f)(y)$ $g(f(x)) = g(f(y))$ $\\text{Since $g$ is 1-1, } f(x) = f(y)$ $\\text{Since $f$ is 1-1, } x = y$ $\\text{That is, } g \\circ f \\text{ is a 1-1 function}$  The Converse is Almost True (Its Still False)  $\\text{Let }f:A \\to B, \\ g:B \\to C$ $\\text{Let } g \\circ f: A \\to C \\text{ be 1-1}$ Then $f$ is 1-1, but $g$ doesnt have to be 1-1  Proof:\n $\\text{Let }f(x) = f(y)$ $\\text{Then } g(f(x)) = g(f(y))$ $(g \\circ f)(x) = (g \\circ f)(y)$ $x = y$ That is, $f$ is 1-1  Onto Functions, Surjections  $\\text{Let } f:A \\to B$ $\\text{The function $f$ is onto if and only if}$  For any $y \\in B$ There exists some $x \\in A$ Such that $f(x) = y$   In words, A function is onto if and only if every element in the codomain has a non-empty pre-image. An onto function is also called a surjection.   Onto Means Range is Codomain Proof:\n Let $f: A \\to B$ be onto. Onto implies $B \\subseteq f(A)$ Let $y \\in B$ There exists $x \\in A$ such that $f(x) = y$ $y \\in f(A)$ That is, $B \\subseteq A$ But $f(A) \\subseteq B$ That is, $B = f(A)$  Example:\n Let $f: \\Bbb Z\\to \\Bbb Z$ with $f(x) = x^2$ $f$ is not onto because there is no integer $x$ such that $f(x) = -1$  Composition of Surjections Theorem  $\\text{Let }f:A \\to B, \\ g:B \\to C$ $\\text{If both $f$ and $g$ are onto then } g \\circ f \\text{ is also onto.}$ That is, the composition of onto functions is onto.   Proof:\n $\\text{Let } z \\in C$ $\\text{Since } g: B \\to C \\text{ is onto, there is a } y \\in B \\text{ such that }g(y) = z$ $\\text{Since } f: A \\to B \\text{ is onto, there is an } x \\in A \\text{ such that }f(x) = y$ $\\text{Combining, we have }(g \\circ f)(x) = g(f(x)) = g(y) = z$ $\\text{That is, the composition }g \\circ f \\text{ is onto.}$  The Converse is Almost True (Its Still False.. Again..) Proof:\n $\\text{Let }f:A \\to B,\\ g:B \\to C$ $\\text{Let }g \\circ f:A \\to C \\text{ be onto.}$ $\\text{Then $g$ is onto, but $f$ need not be onto}$ $\\text{Since $g \\circ f$ is onto, for any $z \\in C$, there is an $x \\in A$ such that $(g \\circ f)(x) = z$}$ $\\text{That is, } g(f(x))=z$ $\\text{But }f(x) \\in B$ $\\text{So for any } z \\in C, \\text{ there is a } y = f(x) \\in B \\text{ such that } g(y) = x$ $\\text{That is, $g$ is onto.}$  1-1 and Onto Functions, Bijections, 1-1 Correspondences  Let $f:A \\to B$ The function $f$ is a 1-1 correspondence if and only if $f$ is 1-1 and onto. A 1-1 correspondence is also called a bijection.  Composition of Bijections Theorem  Let $f:A \\to B, \\ g:B \\to C$ If both $f$ and $g$ are both bijections, then $g \\circ f$ is also a bijection That is, the composition of bijections is a bijection.   Proof:\n Since $f$ and $g$ are 1-1, so is $g \\circ f$ Since $f$ and $g$ are onto, so is $g \\circ f$ Since $g \\circ f$ is 1-1 and onto, $g \\circ f$ is a bijection.  The Converse is Almost True (Its Still False.. Again.. Again..)  Since $g \\circ f$ is 1-1  $f$ is 1-1 $g$ may not be 1-1   Since $g \\circ f$ is onto  $g$ is onto $f$ may not be onto   That is, $f$ and $g$ need not be bijections.  Making an Injection a Bijection  Let $f:A \\to B$ be 1-1 Let $C = f(A)$ Then $f:A \\to C$ is a bijection  $f$ remains 1-1 $f$ has become onto    $f$ is a Bijection $\\implies f^{-1}$ is a Function  A function is invertible if and only if its inverse is also a function  Theorem  Let $f:A \\to B$. If $f$ is a bijection, then $f^{-1}$ is a function.   Proof:\n Let $f:A \\to B$ be a bijection. We want to show that $f^{-1} \\subseteq B \\times A$ is a function We need to show:  For any $y \\in B$, there is an $x \\in A$ such that $(y,x) \\in f^{-1}$ If $(y,x),(y,x^\\prime) \\in f^{-1}$, then $x=x^\\prime$    Proof for 1 (Every Member ofB Has an Image under $f^{-1}$):\n Let $y \\in B$ Since $f$ is onto, there is an $x \\in A$ such that $f(x) = y$ That is, for any $y \\in B$, there is an $x \\in A$, such that $(x,y) \\in f$ But $(x,y) \\in f \\implies (y,x) \\in f^{-1}$  Proof for 2 (The Image Under $f^{-1} is Unique$):\n Let $y \\in B$ Let $(y,x), (y,x^\\prime) \\in f^{-1}$ We have $(x,y), (x^\\prime, y) \\in f$ This gives $f(x) = y = f(x^\\prime)$ But $f$ is 1-1 gives $x = x^\\prime$  $f^{-1}$ is a Function $\\implies f$ is a Bijection Inverse Functions  Let $f:A \\to B$ Since $f$ is a function, it is a relation We know $f^{-1}$ is a relation from $B$ to $A$. If $f^{-1}$ is a function, then $f$ is 1-1 and onto.  Theorem  Let $f:A \\to B$ If $f^{-1}$ is a function, then $f$ is 1-1 and onto   Proof:\n Given $f^{-1}:B \\to A$ is a function We want to show $f:A \\to B$ is 1-1 and onto We need to show  $f(x) = f(x^\\prime) \\implies x = x^\\prime$ For any $y \\in B$, there is an $x \\in A$ such that $f(x) = y$    Proof $f$ is 1-1:\n Let $f(x) = f(x^\\prime) = y$ We have $(x,y),(x^\\prime ,y) \\in f$ $(y,x),(y,x^\\prime) \\in f^{-1}$ but $f^{-1}$ is a function, so the image of $y$ under it is unique, that is, $x=x^\\prime$ Since $x=x^\\prime$ whenever $f(x) = f(x^\\prime)$, $f$ is 1-1  Proof $f$ is onto:\n For any $y \\in B$, let $f^{-1}(y)=x$. That is, $(y,x) \\in f^{-1}$ $(x,y) \\in f$ and thus $f(x) = y$ Since any member of $B$ has a non-empty pre-image under $f$, $f$ is onto.  Properties of Inverse Functions The Inverse Image and the Pre-Image  Let $f:A \\to B$ and $f^{-1}:B \\to A$ We have $(x,y) \\in f$ if and only if $(y,x) \\in f^{-1}$ Since both $f$ and $f^{-1}$ are functions, the above can be written as $f(x) = y \\text{ iff }f^{-1}(y) = x$  Theorem If the inverse of a function is a function, the inverse function is a bijection  Proof:\n Let the functions $f$ and $f^{-1}$ be functions We have $(f^{-1})^{-1} = f$ is a function Since the inverse of $f^{-1}$ is a function, by a previous theorem, $f^{-1}$ is a bijection.  Function Composition Properties  Let $f:A \\to B$ be 1-1 and onto We have $f^{-1}:B \\to A$ is also 1-1 and onto We want to find:  $f \\circ f^{-1}$ $f^{-1} \\circ f$ $f \\circ I_A,\\ I_B \\circ f$ $I_A \\circ f^{-1},\\ f^{-1} \\circ I_B$    $f \\circ f^{-1}$  We have $f^{-1}: B \\to A, \\ f:A \\to B$ Let $(f \\circ f^{-1})(x) = y$  $f(f^{-1}(x)) = y$ $f^{-1}(x) = f^{-1}(y)$ But $f^{-1}$ is a bijection So $x = y$ And $f \\circ (f^{-1})(x) = x$   That is, $f \\circ f^{-1} = I_B$  $f^{-1} \\circ f$  We have $f:A \\to B, \\ f^{-1}:B \\to A$ Let $(f^-1 \\circ f)(x) = y$  $f^{-1}(f(x)) = y$ $f(x) = f(y)$ But $f$ is a bijection So $x = y$ And $f(^{-1} \\circ f)(x) = x$   That is, $f^{-1} \\circ f = I_A$  $f \\circ I_A$  We have $I_A:A \\to A, \\ f:A \\to B$ Let $(f\\circ I_A)(x) = y$  $f(I_A(x)) = y$ $f(x) = y$ $(f \\circ I_A)(x) = f(x)$   That is $f \\circ I_A = f$  $I_B \\circ f$  We have $f:A \\to B, \\ I_B:B \\to B$ Let $(I_B \\circ f)(x) = y$  $I_B(f(x)) = y$ $f(x) = y$ $(I_B \\circ f)(x) = f(x)$   That is $I_B \\circ f = f$  $I_A \\circ f^{-1}, \\ f^{-1} \\circ I_B$ Using a similar proof to the last two sections, we have:\n $I_A \\circ f^{-1} = f^{-1}$ $f^{-1} \\circ I_B = f^{-1}$  Questions Let $|A| = m$ and $|B| = n$. What is the total number of functions from $A \\to B$?\n Answer ↕  $$n^m$$    Let $|A| = m$ and $|B| = n$, where $m \\geq n$. What is the total number of onto functions from $A \\to B$?\n Answer ↕  $$\\sum_{k=0}^n(-1)^k{n \\choose k}(n-k)^m$$    Let $|A| = m$ and $|B| = n$, where $m \\leq n$. What is the total number of one-to-one functions from $A \\to B$?\n Answer ↕  $$m!{n \\choose m}$$     Foundation for Cryptography The Floor and Ceiling Function The Floor Function $\\lfloor x \\rfloor$ The largest integer $\\leq x$\nThe Ceiling Function $\\lceil x \\rceil$ The smallest integer $\\geq x$\n Quotient and Remainder Division Algorithm Let $b \\not = 0$ be an integer and let $a$ be any integer. Then there are two unique integers $q$ and $0 \\leq r \\leq |b|$ such that $a = qb+r$  Proof (Constructive):\n Define $\\mathcal E_b = 1$ if $b \u0026gt; 0$ and $\\mathcal E_b = -1$ if $b \u0026lt; 0$ Let $q = \\left \\lfloor \\frac{a}{b \\mathcal E_b} \\right \\rfloor$ and $r = a-q \\mathcal E_b b$ It can be checked that $0 \\leq r \\leq |b|$ and that $a = bq + r$ Proof of uniqueness of $q$ and $r$  Exercise    Definition $q$ and $r$ in the proof above are the quotient and remainder when $a$ is divided by $b$.\nWe write $r = a \\mod b$\nIf $a \\mod b = 0, \\ b$ is called a divisor or factor of $a$. In this case, we sat that $a$ is divisible by $b$ or $b$ divides $a$.\n Definition The greatest common divisor (GCD) of two integers $a$ and $b$, denoted by $\\gcd (a,b)$, is the largest among all the common divisors of $a$ and $b$.  Proposition $\\gcd (b,a) = \\gcd (-b,a) = \\gcd (b,-a) = \\gcd (-b,-a) = \\gcd (a,b)$  Because of the proposition above we will only consider the case that $a \\geq 0$ and $b \\geq 0$ later on.\nProposition Let $a$ and $b$ be two integers such that $(a,b) \\not = (0,0)$. Then $\\gcd (b,a)$ must exist  Proof:\nThe total number of positive common divisors of $a$ and $b$ is at most $\\max (|a|,|b|)$\nThe Euclidean Algorithm Lemma Let $b \\not = 0$. Then $\\gcd (a,b) = \\gcd (b,\\ a\\mod b)$  Proof:\n Note that $a = qb + r$, where $r = a \\mod b$ is the remainder. By this equation, any common divisor of $a$ and $b$ must be a common divisor of $b$ and $r$. Hence the two sets of integers have the same GCD.  Remark:\nA recursive application of this lemma gives an efficient algorithm for computing the gcd(a,b), which is called the Euclidean Algorithm\nPseudo Code  $x \\leftarrow a;\\ y \\leftarrow b$ $\\text{If } y = 0, \\text{ return } \\gcd (a,b) = x$ $r \\leftarrow x \\mod y$ $x \\leftarrow y$ $y \\leftarrow r$ $\\text{Go to step 2.}$  The time complexity of this algorithm is $O(\\log |b| \\times [\\log |b| + \\log |a|]^2)$\nModulo $n$ Arithmetic Let $n \u0026gt; 1$ be an integer. We define:\n $x \\oplus _n y = (x + y) \\mod n$ $x \\ominus _n y = (x - y) \\mod n$ $x \\otimes _n y = (x \\times y) \\mod n$ Where $+,-,\\times$ are integer operators. $\\oplus_n$ is called modulo-n addition. $\\ominus_n$ is called modulo-n subtraction. $\\otimes_n$ is called modulo-n multiplicaiton. $n$ is called the modulus.   Properties of Modulo $n$ Operations Proposition Let $n \u0026gt; 1$ be the modulus, $\\Bbb Z = \\{0,1,\u0026hellip;,(n-1)\\}$\n  Commutative laws: $$x \\oplus_n y = y \\oplus_n x,\\ x \\otimes_n y = y \\otimes_n x $$\n  Associative Laws: $$(x \\oplus_n y) \\oplus_n z = x \\oplus_n (y \\oplus_n z )$$ $$(x \\otimes_n y) \\otimes_n z = x \\otimes_n (y \\otimes_n z )$$\n  Distribution Law: $$z \\otimes_n (x \\oplus_n y) = (z \\otimes_n x) \\oplus_n (z \\otimes_n y)$$\n   The Multiplicative Inverse Definition Let $x \\in \\Bbb Z_n = {0,1,\u0026hellip;,(n-1)}$. If there is an integer $y \\in \\Bbb Z_n$ such that\n$$x \\otimes_n =: (x \\times y) \\mod n = 1y$$\nThe integer $y$ is called a multiplicative inverse of $x$, usually denoted as $x^{-1}$. (It is unique if it exists)\n $\\gcd (a,b)$ as a linear combination of $a$ and $b$ Lemma There are two integers $u$ and $v$ such that $\\gcd (a,b) = ua + vb$  Proof:\nSet $a_0 = a$ and $a_1 = b$. By the EA, we have:  \\[\\begin{matrix} a_0 \u0026amp; = \u0026amp; q_1 \u0026amp; \\times \u0026amp; a_1 \u0026amp; \u0026#43; \u0026amp; a_2 \\\\ a_1 \u0026amp; = \u0026amp; q_2 \u0026amp; \\times \u0026amp; a_2 \u0026amp; \u0026#43; \u0026amp; a_3 \\\\ \u0026amp; \\vdots \u0026amp; \u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\ a_{t-2} \u0026amp; = \u0026amp; q_{t-1} \u0026amp; \\times \u0026amp; a_{t-1} \u0026amp; \u0026#43; \u0026amp; a_t \\\\ a_{t-1} \u0026amp; = \u0026amp; q_t \u0026amp; \\times \u0026amp; a_t \u0026amp; \u0026#43; \u0026amp; 0 \\\\ \\end{matrix}\\]  Where $a_i \\not = 0$ for $i \\leq t$. Hence, $\\gcd (a,b) = a_t$. Reversing back, we can express $a_t$ as a linear combination of $a_0$ and $a_1$.\nPreposition If $a \\in \\Bbb Z_n$ has a multiplicative inverse, then it is unique.  Proof:\nLet $b \\in \\Bbb Z_n$ and $c \\in \\Bbb Z_n$ be two multiplicative inverses of a. Then $a \\otimes_n b = 1$ and $a \\otimes_n c = 1$. By definition\n$$a \\otimes_n b \\otimes_n c = (a \\otimes_n b) \\otimes_n c = 1 \\otimes_n c = c$$\nOn the other hand, by associativity and commutativity,\n$$a \\otimes_n b \\otimes_n c = b \\otimes_n (a \\otimes_n c )= b \\otimes_n 1 = b$$\nHence $b = c$\nTheorem Let $n \u0026gt;1$ be an integer. Then any $a \\in \\Bbb Z_n$ has the multiplicative inverse modulo $n$ if and only if $\\gcd (a,n) = 1$  Proof:\nSuppose that $\\gcd (a,n) = e \\not = 1$. Then $n = e n_1$ for some $n_1 \u0026lt; n$, and $a = ea_1$.\nThen $n_1 \\otimes_n a = 0$. If there were an element $b \\in \\Bbb Z_n$ such that $a \\otimes_n b = 1$ then we would have\n$$n_1 \\otimes_n (a \\otimes b) = n_1 \\otimes_n 1 = n_1 \\mod n = n_1$$\nand\n$$n_1 \\otimes_n (a \\otimes_n b) = (n_1 \\otimes_n a) \\otimes_n b = 0$$\nHence, $n_1 = 0$, a contradiction. By the lemma here, there are two integers $u$ and $v$ such that $1 = ua + vn$. Hence $au \\mod n = 1$. Define $a^\\prime = u \\mod n$. Then $aa^\\prime \\mod n = 1$\nComputing the Multiplicative Inverse Let $a \\in \\Bbb Z_n$ with $\\gcd (a,n)=1$. Apply the extended euclidean algorithm to $a$ and $n$ to compute the two integers $u$ and $v$ such that $1 = ua + vn$. Then $u \\mod n$ is the inverse of $a$ modulo $n$.\nExample:\nFind $35^{-1} \\mod 66$\n First show that $\\gcd (35,66) = 1$ If the above is true, then find $u,v$ such that $1 = ua + vn$ return $u \\mod n$   \\[\\begin{matrix} 66 \u0026amp; = \u0026amp; 1 \\times 35 \u0026#43; 31 \u0026amp; \u0026amp; 1 \u0026amp; = \u0026amp; -9 \\times 66 \u0026#43; 17 \\times 35 \\\\ 35 \u0026amp; = \u0026amp; 1 \\times 31 \u0026#43; 4 \u0026amp; \u0026amp; 1 \u0026amp; = \u0026amp; 8 \\times 35 -9 \\times 31 \\\\ 31 \u0026amp; = \u0026amp; 7 \\times 4 \u0026#43; 3 \u0026amp; \u0026amp; 1 \u0026amp; = \u0026amp; -1 \\times 31 \u0026#43;8 \\times 4 \\\\ 4 \u0026amp; = \u0026amp; 1 \\times 3 \u0026#43; 1 \u0026amp; \u0026amp; 1 \u0026amp; = \u0026amp; 4 - 1 \\times 3 \\\\ 3 \u0026amp; = \u0026amp; 3 \\times 1 \u0026#43; 0 \u0026amp; \u0026amp; \u0026amp; \u0026amp; \\end{matrix}\\]  From this we can see that $u = 17$. Therefore $35^{-1} \\mod 66 = u \\mod 66 = 17$.\nFinite Fields $\\Bbb Z_p$ (Denoted also by GF(p)) Theorem Let $p$ be a prime. Then every nonzero element in $\\Bbb Z_p$ has the multiplicative inverse modulo $p$.  Definition Let $p$ be a prime. Then the triple $(\\Bbb Z_p, \\oplus_n, \\otimes_n)$ is called a finite field with $p$ elements.   \\[\\begin{array}{c} \\begin{array}{c|cc} \u0026#43; \u0026amp; 0 \u0026amp; 1 \u0026amp; 2\\\\ \\hline 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 2\\\\ 1 \u0026amp; 1 \u0026amp; 2 \u0026amp; 0\\\\ 2 \u0026amp; 2 \u0026amp; 0 \u0026amp; 1 \\end{array} \u0026amp; \\begin{array}{c|cccc} \\times \u0026amp;0\u0026amp;1\u0026amp;2\\\\ \\hline 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 1 \u0026amp; 0 \u0026amp; 1 \u0026amp; 2\\\\ 2 \u0026amp; 0 \u0026amp; 2 \u0026amp; 1 \\end{array} \\end{array} \\\\ \\text{Finite Field } \\Bbb Z_3\\]  Remarks: $\\times$ stands for $\\otimes_3$, and $+$ stands for $\\oplus_3$.\n"});index.add({'id':13,'href':'/COMP4631/01.-Introduction-and-Physical-Security/','title':"Course Introduction and Physical Security",'section':"COMP4631 - Computer and Communication Security",'content':"Course Introduction and Physical Security Topics to be Covered  Computer Security: An Introduction Conventional Cryptosystems Public-Key Cryptosystems Key Management Hash Functions, Authentication Digital Signature, Identification Access Control Unix Security Windows NT Security Distributed System Security Network Security IP Security Email Security Web Security Firewalls Virtual Private Networks  Reference Books  Behrouz A. Forouz, Cryptography and Network Security, McGraw Hill, 2008. D. Gollmann, Computer Security, John Wiley \u0026amp; Sons, 1999. W. Stallings and L. Brown, Computer Security: Principles and Practice, Pearson Education, 2008.   Physical Security  Physical security refers to the protection of building sites and equipment (and all information and software contained therein) from theft, vandalism, natural disaster, manmade catastrophes, and accidental damage (e.g., from electrical surges, extreme temperatures, and spilled coffee).  Elements of Physical Security  Obstacles, to frustrate trivial attacker and delay serious ones. (Prevention) Alarms, security lighting, guard patrols, closed-circuit cameras to make it likely that an attack will be noticed. (Detection) Security response, to repel, catch or frustrate attackers when an attack is detected. (Response)  In a well-designed system, these features must complement each other.\nDesign of Physical Security   Environmental Design (Prevention)\n The intial layer of security of a physical space. Used to deter threats Examples: warnings, fences, vehicle height restrictors, etc\u0026hellip;    Mechanical and Electronic Access Control (Prevention)\n Second layer of physical security Access control policy is what determines who grants access and how. Could be a guard controlled door, or a simple RFID card. Examples: Doors with locks, guard controlled doors or gates, etc\u0026hellip;    Intrusion detection (Detection)\n Third layer of physical security Monitors for attacks Less of a preventative measure, and more of a responsive measure.    Violating Physical Access Control  Masquerading: A person A person disguised as an authorized user. This can be done using a forged ID or pretending to be a repair man. Piggy-Backing: A person who enters the security perimeter by following an authorized user. Lock Picking: Any lock can be picked. Or better, go through dropped ceilings or removing the hinges from door. Visual/Auditory Access: Using side channels to get information which enable access.  Summary  Physical security helps:  Understand computer security Strengthen computer security    Physcial security is combined with information security in many real-world applications. Physical security is a vital part of any security plan and is fundamental to all security efforts. Without it, information security, software security, user access security and network security are considered more difficult, if not possible, to initiate.\n Source(s):\n  Course Notes (Lecture 1)  "});index.add({'id':14,'href':'/COMP4632/','title':"COMP4632 - Practicing Cybersecurity: Attacks and Counter-measures",'section':"Home",'content':"COMP4632 - Practicing Cybersecurity: Attacks and Counter-measures This course equips students with cybersecurity knowledge and current IT practices on security risk management. Through hands-on laboratory sessions, students will understand existing IT security issues, learn how to assess IT security risks, and conduct experiments on ethical hacking. They will practice system attack and defense strategies using security tools, so as to gain practical experience to become a cybersecurity professional. The course covers current security trends, industrial practices on IT security, design requirements for secure web and mobile applications, security assessment, risk analysis and risk management. Knowledge in web programming and database administration is not essential but a plus.\n  "});index.add({'id':15,'href':'/about/','title':"About",'section':"Home",'content':"Some big markdown smaller\u0026hellip; "});index.add({'id':16,'href':'/ELEC1010/','title':"ELEC1010 - Electronic and Information Technology",'section':"Home",'content':"ELEC1010 - Electronic and Information Technology This general-education course introduces the basics of electronic and information technology and their applications to daily-life consumer electronics and communication devices. Contents include the representation of signals in the time and frequency domains; digitization of information; coding for data compression and error protection; transmission of signals; cellular mobile phones and wireless communications; and the Internet. It is expected that through studying these technologies and how they address the problems encountered in the information technology area, students will also grasp the skills in solving problems with engineering approach and spirit and appreciate how these technologies impact the society.\n  "});})();