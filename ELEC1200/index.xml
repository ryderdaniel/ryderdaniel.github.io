<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ELEC1200 - A System View of Communications: from Signals to Packets on Spring 2021</title>
    <link>http://ryderdaniel.github.io/ELEC1200/</link>
    <description>Recent content in ELEC1200 - A System View of Communications: from Signals to Packets on Spring 2021</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 11 Mar 2021 14:19:28 +0800</lastBuildDate>
    
	<atom:link href="http://ryderdaniel.github.io/ELEC1200/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Lecture8</title>
      <link>http://ryderdaniel.github.io/ELEC1200/Lecture8/</link>
      <pubDate>Thu, 11 Mar 2021 14:19:28 +0800</pubDate>
      
      <guid>http://ryderdaniel.github.io/ELEC1200/Lecture8/</guid>
      <description>Intuition for Equalizer  Due to ISI, the output doesnt always move far enough to cross the threshold in response to a change in the bit Thus, looking at the value or level of the output is not a reliable way to determine the input bit. When the input goes from zero to one,  The channel output does not immediately move to $k$. Rather the output starts to change from zero to $k$.</description>
    </item>
    
    <item>
      <title>Lecture 7</title>
      <link>http://ryderdaniel.github.io/ELEC1200/Lecture7/</link>
      <pubDate>Thu, 11 Mar 2021 12:37:17 +0800</pubDate>
      
      <guid>http://ryderdaniel.github.io/ELEC1200/Lecture7/</guid>
      <description>Motivation: Equalization  The channel introduces ISI which causes the eye to close. The goal of a channel equalizer is to undo the effect of the channel. This will cause the eye to open.  Developing the Equalizer  How can we figure out what to put into the channel equalizer?  We need to describe the effect of the channel using a model that enables us to predict the channel output for any input.</description>
    </item>
    
    <item>
      <title>Lecture 6</title>
      <link>http://ryderdaniel.github.io/ELEC1200/Lecture6/</link>
      <pubDate>Thu, 04 Mar 2021 16:33:28 +0800</pubDate>
      
      <guid>http://ryderdaniel.github.io/ELEC1200/Lecture6/</guid>
      <description>Trade-Off Between bit-rate and BER  Bit rate - the number of bits that can be transmitter per second (we want this to be as high as possible) Bit Error Rate (BER) - Fraction of bits that are wrongly decoded by the reciever.  We want this to be low BER rate decreases as bit time increases BER increases with smaller bit time (SPB) BER increases if the channel is noisier or if we use less power to transmit a signal.</description>
    </item>
    
    <item>
      <title>Lecture 5</title>
      <link>http://ryderdaniel.github.io/ELEC1200/Lecture5/</link>
      <pubDate>Thu, 04 Mar 2021 15:14:31 +0800</pubDate>
      
      <guid>http://ryderdaniel.github.io/ELEC1200/Lecture5/</guid>
      <description>Protocols Agreement on a set of rules or procedures to follow during communication.   Protocols are necessary for any communication system  Without them, one can hear but not understand    Protocols in Data Communication Systems  In data communication, protocols cover all aspects of data representation and signalling including:  The representation of text characters The order in which bit sequences are sent    Decoding Bits Thresholding  In our system, for long SPBs at the reciever:  &amp;ldquo;1&amp;rdquo; bits correspond to a number of samples with value c + k &amp;ldquo;0&amp;rdquo; bits correspond to a number of samples with value c Thus we can decide whether a bit is 0 or 1 by comparing to a threshold of c + k/2 Let $r(n)$ be the recieved signal at time $n$, and $b(n)$ the result of thresholding:</description>
    </item>
    
    <item>
      <title>Lecture 4</title>
      <link>http://ryderdaniel.github.io/ELEC1200/Lecture4/</link>
      <pubDate>Thu, 25 Feb 2021 18:00:13 +0800</pubDate>
      
      <guid>http://ryderdaniel.github.io/ELEC1200/Lecture4/</guid>
      <description>Linear Time Invariant Systems Systems  For this class, a system is something that takes a waveform $x(n)$ and produces an output waveform $y(n)$ e.g. a channel.  Linear Systems  A linear system is a system that satisfies the following two properties:  Homogeneity:
$$x(n) \to |\text{ system }| \to y(n) \implies c \cdot x(n) \to |\text{ system }| \to c \cdot y(n)$$  If you scale the input by $c$ times, the output is also scaled by $c$ times.</description>
    </item>
    
    <item>
      <title>Lecture3</title>
      <link>http://ryderdaniel.github.io/ELEC1200/Lecture3/</link>
      <pubDate>Thu, 25 Feb 2021 13:17:07 +0800</pubDate>
      
      <guid>http://ryderdaniel.github.io/ELEC1200/Lecture3/</guid>
      <description>Representing Bit Waveforms Equivalent Representations of Waveforms  Verbal: The encoding of the bit sequence $1010001$ at 4 samples per bit. Graph:
 List, Table or Vector of Values:
$n = [0, 1, 2, 3, &amp;hellip;]$
$x(n) = [1, 1, 1, 0, &amp;hellip;]$ Sum of Unit Step Functions:
$x(n) = u(n) - u(n-4) + u(n-8) + &amp;hellip; + u(n + m)$  Uses for Different Representations  The four representations are equivalent in that if we know one, we can obtain any of the others.</description>
    </item>
    
    <item>
      <title>Lecture2</title>
      <link>http://ryderdaniel.github.io/ELEC1200/Lecture2/</link>
      <pubDate>Thu, 25 Feb 2021 10:55:00 +0800</pubDate>
      
      <guid>http://ryderdaniel.github.io/ELEC1200/Lecture2/</guid>
      <description>Recap of Lecture 1 Representing Bit Sequences as Waveforms  A bit sequence can be encoded by changing the value of a physical variable over time Each bit is encoded by holding the state constant over a length of time known as the bit time. The shorter the bit time, the faster we can transmit information (bits).  Encoding information with Bits Bits  A bit is the basic unit of information used in modern computers and communication systems.</description>
    </item>
    
  </channel>
</rss>